/* automatically generated by rust-bindgen */

pub const __GNUCLIKE_ASM: ::std::os::raw::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE___SECTION: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: ::std::os::raw::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: ::std::os::raw::c_uint = 1;
pub const __POSIX_VISIBLE: ::std::os::raw::c_uint = 200809;
pub const __XSI_VISIBLE: ::std::os::raw::c_uint = 700;
pub const __BSD_VISIBLE: ::std::os::raw::c_uint = 1;
pub const __ISO_C_VISIBLE: ::std::os::raw::c_uint = 2011;
pub const __EXT1_VISIBLE: ::std::os::raw::c_uint = 1;
pub const __CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const __SCHAR_MAX: ::std::os::raw::c_uint = 127;
pub const __SCHAR_MIN: ::std::os::raw::c_int = -128;
pub const __UCHAR_MAX: ::std::os::raw::c_uint = 255;
pub const __USHRT_MAX: ::std::os::raw::c_uint = 65535;
pub const __SHRT_MAX: ::std::os::raw::c_uint = 32767;
pub const __SHRT_MIN: ::std::os::raw::c_int = -32768;
pub const __UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const __INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const __ULONG_MAX: ::std::os::raw::c_int = -1;
pub const __LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: ::std::os::raw::c_int = -1;
pub const __LLONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: ::std::os::raw::c_int = -1;
pub const __OFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: ::std::os::raw::c_int = -1;
pub const __QUAD_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __LONG_BIT: ::std::os::raw::c_uint = 64;
pub const __WORD_BIT: ::std::os::raw::c_uint = 32;
pub const __MINSIGSTKSZ: ::std::os::raw::c_uint = 2048;
pub const __WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const __WCHAR_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: ::std::os::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::std::os::raw::c_uint = 0;
pub const _LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const _BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const _PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const _BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const true_: ::std::os::raw::c_uint = 1;
pub const _SIG_WORDS: ::std::os::raw::c_uint = 4;
pub const _SIG_MAXSIG: ::std::os::raw::c_uint = 128;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const MDT_DEPEND: ::std::os::raw::c_uint = 1;
pub const MDT_MODULE: ::std::os::raw::c_uint = 2;
pub const MDT_VERSION: ::std::os::raw::c_uint = 3;
pub const MDT_PNP_INFO: ::std::os::raw::c_uint = 4;
pub const MDT_STRUCT_VERSION: ::std::os::raw::c_uint = 1;
pub const MDT_SETNAME: &'static [u8; 16usize] = b"modmetadata_set\x00";
pub const MAXMODNAME: ::std::os::raw::c_uint = 32;
pub const CR4_PGE: ::std::os::raw::c_uint = 128;
pub const INVPCID_ADDR: ::std::os::raw::c_uint = 0;
pub const INVPCID_CTX: ::std::os::raw::c_uint = 1;
pub const INVPCID_CTXGLOB: ::std::os::raw::c_uint = 2;
pub const INVPCID_ALLCTX: ::std::os::raw::c_uint = 3;
pub const MSR_FSBASE: ::std::os::raw::c_uint = 3221225728;
pub const MSR_GSBASE: ::std::os::raw::c_uint = 3221225729;
pub const CALLOUT_LOCAL_ALLOC: ::std::os::raw::c_uint = 1;
pub const CALLOUT_ACTIVE: ::std::os::raw::c_uint = 2;
pub const CALLOUT_PENDING: ::std::os::raw::c_uint = 4;
pub const CALLOUT_MPSAFE: ::std::os::raw::c_uint = 8;
pub const CALLOUT_RETURNUNLOCKED: ::std::os::raw::c_uint = 16;
pub const CALLOUT_SHAREDLOCK: ::std::os::raw::c_uint = 32;
pub const CALLOUT_DFRMIGRATION: ::std::os::raw::c_uint = 64;
pub const CALLOUT_PROCESSED: ::std::os::raw::c_uint = 128;
pub const CALLOUT_DIRECT: ::std::os::raw::c_uint = 256;
pub const C_DIRECT_EXEC: ::std::os::raw::c_uint = 1;
pub const C_PRELBITS: ::std::os::raw::c_uint = 7;
pub const C_PRELRANGE: ::std::os::raw::c_uint = 127;
pub const C_HARDCLOCK: ::std::os::raw::c_uint = 256;
pub const C_ABSOLUTE: ::std::os::raw::c_uint = 512;
pub const C_PRECALC: ::std::os::raw::c_uint = 1024;
pub const CS_DRAIN: ::std::os::raw::c_uint = 1;
pub const CS_EXECUTING: ::std::os::raw::c_uint = 2;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const WCHAR_MAX: ::std::os::raw::c_uint = 2147483647;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const HASH_NOWAIT: ::std::os::raw::c_uint = 1;
pub const HASH_WAITOK: ::std::os::raw::c_uint = 2;
pub const HD_COLUMN_MASK: ::std::os::raw::c_uint = 255;
pub const HD_DELIM_MASK: ::std::os::raw::c_uint = 65280;
pub const HD_OMIT_COUNT: ::std::os::raw::c_uint = 65536;
pub const HD_OMIT_HEX: ::std::os::raw::c_uint = 131072;
pub const HD_OMIT_CHARS: ::std::os::raw::c_uint = 262144;
pub const LIBKERN_LEN_BCD2BIN: ::std::os::raw::c_uint = 154;
pub const LIBKERN_LEN_BIN2BCD: ::std::os::raw::c_uint = 100;
pub const LIBKERN_LEN_HEX2ASCII: ::std::os::raw::c_uint = 36;
pub const ARC4_ENTR_NONE: ::std::os::raw::c_uint = 0;
pub const ARC4_ENTR_HAVE: ::std::os::raw::c_uint = 1;
pub const ARC4_ENTR_SEED: ::std::os::raw::c_uint = 2;
pub const FNM_NOMATCH: ::std::os::raw::c_uint = 1;
pub const FNM_NOESCAPE: ::std::os::raw::c_uint = 1;
pub const FNM_PATHNAME: ::std::os::raw::c_uint = 2;
pub const FNM_PERIOD: ::std::os::raw::c_uint = 4;
pub const FNM_LEADING_DIR: ::std::os::raw::c_uint = 8;
pub const FNM_CASEFOLD: ::std::os::raw::c_uint = 16;
pub const FNM_IGNORECASE: ::std::os::raw::c_uint = 16;
pub const FNM_FILE_NAME: ::std::os::raw::c_uint = 2;
pub const BSD: ::std::os::raw::c_uint = 199506;
pub const BSD4_3: ::std::os::raw::c_uint = 1;
pub const BSD4_4: ::std::os::raw::c_uint = 1;
pub const __FreeBSD_version: ::std::os::raw::c_uint = 1200031;
pub const P_OSREL_SIGWAIT: ::std::os::raw::c_uint = 700000;
pub const P_OSREL_SIGSEGV: ::std::os::raw::c_uint = 700004;
pub const P_OSREL_MAP_ANON: ::std::os::raw::c_uint = 800104;
pub const P_OSREL_MAP_FSTRICT: ::std::os::raw::c_uint = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: ::std::os::raw::c_uint = 1100077;
pub const ARG_MAX: ::std::os::raw::c_uint = 262144;
pub const CHILD_MAX: ::std::os::raw::c_uint = 40;
pub const LINK_MAX: ::std::os::raw::c_uint = 32767;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 1023;
pub const OPEN_MAX: ::std::os::raw::c_uint = 64;
pub const PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const IOV_MAX: ::std::os::raw::c_uint = 1024;
pub const MAXCOMLEN: ::std::os::raw::c_uint = 19;
pub const MAXINTERP: ::std::os::raw::c_uint = 1024;
pub const MAXLOGNAME: ::std::os::raw::c_uint = 33;
pub const MAXUPRC: ::std::os::raw::c_uint = 40;
pub const NCARGS: ::std::os::raw::c_uint = 262144;
pub const NGROUPS: ::std::os::raw::c_uint = 1024;
pub const NOFILE: ::std::os::raw::c_uint = 64;
pub const NOGROUP: ::std::os::raw::c_uint = 65535;
pub const MAXHOSTNAMELEN: ::std::os::raw::c_uint = 256;
pub const SPECNAMELEN: ::std::os::raw::c_uint = 63;
pub const EPERM: ::std::os::raw::c_uint = 1;
pub const ENOENT: ::std::os::raw::c_uint = 2;
pub const ESRCH: ::std::os::raw::c_uint = 3;
pub const EINTR: ::std::os::raw::c_uint = 4;
pub const EIO: ::std::os::raw::c_uint = 5;
pub const ENXIO: ::std::os::raw::c_uint = 6;
pub const E2BIG: ::std::os::raw::c_uint = 7;
pub const ENOEXEC: ::std::os::raw::c_uint = 8;
pub const EBADF: ::std::os::raw::c_uint = 9;
pub const ECHILD: ::std::os::raw::c_uint = 10;
pub const EDEADLK: ::std::os::raw::c_uint = 11;
pub const ENOMEM: ::std::os::raw::c_uint = 12;
pub const EACCES: ::std::os::raw::c_uint = 13;
pub const EFAULT: ::std::os::raw::c_uint = 14;
pub const ENOTBLK: ::std::os::raw::c_uint = 15;
pub const EBUSY: ::std::os::raw::c_uint = 16;
pub const EEXIST: ::std::os::raw::c_uint = 17;
pub const EXDEV: ::std::os::raw::c_uint = 18;
pub const ENODEV: ::std::os::raw::c_uint = 19;
pub const ENOTDIR: ::std::os::raw::c_uint = 20;
pub const EISDIR: ::std::os::raw::c_uint = 21;
pub const EINVAL: ::std::os::raw::c_uint = 22;
pub const ENFILE: ::std::os::raw::c_uint = 23;
pub const EMFILE: ::std::os::raw::c_uint = 24;
pub const ENOTTY: ::std::os::raw::c_uint = 25;
pub const ETXTBSY: ::std::os::raw::c_uint = 26;
pub const EFBIG: ::std::os::raw::c_uint = 27;
pub const ENOSPC: ::std::os::raw::c_uint = 28;
pub const ESPIPE: ::std::os::raw::c_uint = 29;
pub const EROFS: ::std::os::raw::c_uint = 30;
pub const EMLINK: ::std::os::raw::c_uint = 31;
pub const EPIPE: ::std::os::raw::c_uint = 32;
pub const EDOM: ::std::os::raw::c_uint = 33;
pub const ERANGE: ::std::os::raw::c_uint = 34;
pub const EAGAIN: ::std::os::raw::c_uint = 35;
pub const EWOULDBLOCK: ::std::os::raw::c_uint = 35;
pub const EINPROGRESS: ::std::os::raw::c_uint = 36;
pub const EALREADY: ::std::os::raw::c_uint = 37;
pub const ENOTSOCK: ::std::os::raw::c_uint = 38;
pub const EDESTADDRREQ: ::std::os::raw::c_uint = 39;
pub const EMSGSIZE: ::std::os::raw::c_uint = 40;
pub const EPROTOTYPE: ::std::os::raw::c_uint = 41;
pub const ENOPROTOOPT: ::std::os::raw::c_uint = 42;
pub const EPROTONOSUPPORT: ::std::os::raw::c_uint = 43;
pub const ESOCKTNOSUPPORT: ::std::os::raw::c_uint = 44;
pub const EOPNOTSUPP: ::std::os::raw::c_uint = 45;
pub const ENOTSUP: ::std::os::raw::c_uint = 45;
pub const EPFNOSUPPORT: ::std::os::raw::c_uint = 46;
pub const EAFNOSUPPORT: ::std::os::raw::c_uint = 47;
pub const EADDRINUSE: ::std::os::raw::c_uint = 48;
pub const EADDRNOTAVAIL: ::std::os::raw::c_uint = 49;
pub const ENETDOWN: ::std::os::raw::c_uint = 50;
pub const ENETUNREACH: ::std::os::raw::c_uint = 51;
pub const ENETRESET: ::std::os::raw::c_uint = 52;
pub const ECONNABORTED: ::std::os::raw::c_uint = 53;
pub const ECONNRESET: ::std::os::raw::c_uint = 54;
pub const ENOBUFS: ::std::os::raw::c_uint = 55;
pub const EISCONN: ::std::os::raw::c_uint = 56;
pub const ENOTCONN: ::std::os::raw::c_uint = 57;
pub const ESHUTDOWN: ::std::os::raw::c_uint = 58;
pub const ETOOMANYREFS: ::std::os::raw::c_uint = 59;
pub const ETIMEDOUT: ::std::os::raw::c_uint = 60;
pub const ECONNREFUSED: ::std::os::raw::c_uint = 61;
pub const ELOOP: ::std::os::raw::c_uint = 62;
pub const ENAMETOOLONG: ::std::os::raw::c_uint = 63;
pub const EHOSTDOWN: ::std::os::raw::c_uint = 64;
pub const EHOSTUNREACH: ::std::os::raw::c_uint = 65;
pub const ENOTEMPTY: ::std::os::raw::c_uint = 66;
pub const EPROCLIM: ::std::os::raw::c_uint = 67;
pub const EUSERS: ::std::os::raw::c_uint = 68;
pub const EDQUOT: ::std::os::raw::c_uint = 69;
pub const ESTALE: ::std::os::raw::c_uint = 70;
pub const EREMOTE: ::std::os::raw::c_uint = 71;
pub const EBADRPC: ::std::os::raw::c_uint = 72;
pub const ERPCMISMATCH: ::std::os::raw::c_uint = 73;
pub const EPROGUNAVAIL: ::std::os::raw::c_uint = 74;
pub const EPROGMISMATCH: ::std::os::raw::c_uint = 75;
pub const EPROCUNAVAIL: ::std::os::raw::c_uint = 76;
pub const ENOLCK: ::std::os::raw::c_uint = 77;
pub const ENOSYS: ::std::os::raw::c_uint = 78;
pub const EFTYPE: ::std::os::raw::c_uint = 79;
pub const EAUTH: ::std::os::raw::c_uint = 80;
pub const ENEEDAUTH: ::std::os::raw::c_uint = 81;
pub const EIDRM: ::std::os::raw::c_uint = 82;
pub const ENOMSG: ::std::os::raw::c_uint = 83;
pub const EOVERFLOW: ::std::os::raw::c_uint = 84;
pub const ECANCELED: ::std::os::raw::c_uint = 85;
pub const EILSEQ: ::std::os::raw::c_uint = 86;
pub const ENOATTR: ::std::os::raw::c_uint = 87;
pub const EDOOFUS: ::std::os::raw::c_uint = 88;
pub const EBADMSG: ::std::os::raw::c_uint = 89;
pub const EMULTIHOP: ::std::os::raw::c_uint = 90;
pub const ENOLINK: ::std::os::raw::c_uint = 91;
pub const EPROTO: ::std::os::raw::c_uint = 92;
pub const ENOTCAPABLE: ::std::os::raw::c_uint = 93;
pub const ECAPMODE: ::std::os::raw::c_uint = 94;
pub const ENOTRECOVERABLE: ::std::os::raw::c_uint = 95;
pub const EOWNERDEAD: ::std::os::raw::c_uint = 96;
pub const ELAST: ::std::os::raw::c_uint = 96;
pub const ERESTART: ::std::os::raw::c_int = -1;
pub const EJUSTRETURN: ::std::os::raw::c_int = -2;
pub const ENOIOCTL: ::std::os::raw::c_int = -3;
pub const EDIRIOCTL: ::std::os::raw::c_int = -4;
pub const ERELOOKUP: ::std::os::raw::c_int = -5;
pub const DST_NONE: ::std::os::raw::c_uint = 0;
pub const DST_USA: ::std::os::raw::c_uint = 1;
pub const DST_AUST: ::std::os::raw::c_uint = 2;
pub const DST_WET: ::std::os::raw::c_uint = 3;
pub const DST_MET: ::std::os::raw::c_uint = 4;
pub const DST_EET: ::std::os::raw::c_uint = 5;
pub const DST_CAN: ::std::os::raw::c_uint = 6;
pub const SBT_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const ITIMER_REAL: ::std::os::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::std::os::raw::c_uint = 1;
pub const ITIMER_PROF: ::std::os::raw::c_uint = 2;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_VIRTUAL: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROF: ::std::os::raw::c_uint = 2;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 4;
pub const CLOCK_UPTIME: ::std::os::raw::c_uint = 5;
pub const CLOCK_UPTIME_PRECISE: ::std::os::raw::c_uint = 7;
pub const CLOCK_UPTIME_FAST: ::std::os::raw::c_uint = 8;
pub const CLOCK_REALTIME_PRECISE: ::std::os::raw::c_uint = 9;
pub const CLOCK_REALTIME_FAST: ::std::os::raw::c_uint = 10;
pub const CLOCK_MONOTONIC_PRECISE: ::std::os::raw::c_uint = 11;
pub const CLOCK_MONOTONIC_FAST: ::std::os::raw::c_uint = 12;
pub const CLOCK_SECOND: ::std::os::raw::c_uint = 13;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 15;
pub const TIMER_RELTIME: ::std::os::raw::c_uint = 0;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const CPUCLOCK_WHICH_PID: ::std::os::raw::c_uint = 0;
pub const CPUCLOCK_WHICH_TID: ::std::os::raw::c_uint = 1;
pub const TC_DEFAULTPERC: ::std::os::raw::c_uint = 5;
pub const PRI_ITHD: ::std::os::raw::c_uint = 1;
pub const PRI_REALTIME: ::std::os::raw::c_uint = 2;
pub const PRI_TIMESHARE: ::std::os::raw::c_uint = 3;
pub const PRI_IDLE: ::std::os::raw::c_uint = 4;
pub const PRI_FIFO_BIT: ::std::os::raw::c_uint = 8;
pub const PRI_FIFO: ::std::os::raw::c_uint = 10;
pub const PRI_MIN: ::std::os::raw::c_uint = 0;
pub const PRI_MAX: ::std::os::raw::c_uint = 255;
pub const PRI_MIN_ITHD: ::std::os::raw::c_uint = 0;
pub const PI_REALTIME: ::std::os::raw::c_uint = 0;
pub const PI_AV: ::std::os::raw::c_uint = 4;
pub const PI_NET: ::std::os::raw::c_uint = 8;
pub const PI_DISK: ::std::os::raw::c_uint = 12;
pub const PI_TTY: ::std::os::raw::c_uint = 16;
pub const PI_DULL: ::std::os::raw::c_uint = 20;
pub const PI_SOFT: ::std::os::raw::c_uint = 24;
pub const PRI_MIN_REALTIME: ::std::os::raw::c_uint = 48;
pub const PRI_MIN_KERN: ::std::os::raw::c_uint = 80;
pub const PSWP: ::std::os::raw::c_uint = 80;
pub const PVM: ::std::os::raw::c_uint = 84;
pub const PINOD: ::std::os::raw::c_uint = 88;
pub const PRIBIO: ::std::os::raw::c_uint = 92;
pub const PVFS: ::std::os::raw::c_uint = 96;
pub const PZERO: ::std::os::raw::c_uint = 100;
pub const PSOCK: ::std::os::raw::c_uint = 104;
pub const PWAIT: ::std::os::raw::c_uint = 108;
pub const PLOCK: ::std::os::raw::c_uint = 112;
pub const PPAUSE: ::std::os::raw::c_uint = 116;
pub const PRI_MIN_TIMESHARE: ::std::os::raw::c_uint = 120;
pub const PUSER: ::std::os::raw::c_uint = 120;
pub const PRI_MIN_IDLE: ::std::os::raw::c_uint = 224;
pub const PRI_MAX_IDLE: ::std::os::raw::c_uint = 255;
pub const PRI_USER: ::std::os::raw::c_int = -2;
pub const PRI_UNCHANGED: ::std::os::raw::c_int = -1;
pub const FALSE: ::std::os::raw::c_uint = 0;
pub const TRUE: ::std::os::raw::c_uint = 1;
pub const MACHINE: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH32: &'static [u8; 5usize] = b"i386\x00";
pub const MAXCPU: ::std::os::raw::c_uint = 256;
pub const MAXMEMDOM: ::std::os::raw::c_uint = 8;
pub const CACHE_LINE_SHIFT: ::std::os::raw::c_uint = 7;
pub const CACHE_LINE_SIZE: ::std::os::raw::c_uint = 128;
pub const NPTEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PAGE_SHIFT: ::std::os::raw::c_uint = 12;
pub const PAGE_SIZE: ::std::os::raw::c_uint = 4096;
pub const PAGE_MASK: ::std::os::raw::c_uint = 4095;
pub const NPDEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PDRSHIFT: ::std::os::raw::c_uint = 21;
pub const NBPDR: ::std::os::raw::c_uint = 2097152;
pub const PDRMASK: ::std::os::raw::c_uint = 2097151;
pub const NPDPEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PDPSHIFT: ::std::os::raw::c_uint = 30;
pub const NBPDP: ::std::os::raw::c_uint = 1073741824;
pub const PDPMASK: ::std::os::raw::c_uint = 1073741823;
pub const NPML4EPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PML4SHIFT: ::std::os::raw::c_uint = 39;
pub const NBPML4: ::std::os::raw::c_ulonglong = 549755813888;
pub const PML4MASK: ::std::os::raw::c_ulonglong = 549755813887;
pub const MAXPAGESIZES: ::std::os::raw::c_uint = 3;
pub const IOPAGES: ::std::os::raw::c_uint = 2;
pub const IOPERM_BITMAP_SIZE: ::std::os::raw::c_uint = 8193;
pub const KSTACK_PAGES: ::std::os::raw::c_uint = 4;
pub const KSTACK_GUARD_PAGES: ::std::os::raw::c_uint = 1;
pub const DEV_BSHIFT: ::std::os::raw::c_uint = 9;
pub const DEV_BSIZE: ::std::os::raw::c_uint = 512;
pub const BLKDEV_IOSIZE: ::std::os::raw::c_uint = 4096;
pub const DFLTPHYS: ::std::os::raw::c_uint = 65536;
pub const MAXPHYS: ::std::os::raw::c_uint = 131072;
pub const MAXDUMPPGS: ::std::os::raw::c_uint = 16;
pub const MSIZE: ::std::os::raw::c_uint = 256;
pub const MCLSHIFT: ::std::os::raw::c_uint = 11;
pub const MCLBYTES: ::std::os::raw::c_uint = 2048;
pub const MJUMPAGESIZE: ::std::os::raw::c_uint = 4096;
pub const MJUM9BYTES: ::std::os::raw::c_uint = 9216;
pub const MJUM16BYTES: ::std::os::raw::c_uint = 16384;
pub const PRIMASK: ::std::os::raw::c_uint = 255;
pub const PCATCH: ::std::os::raw::c_uint = 256;
pub const PDROP: ::std::os::raw::c_uint = 512;
pub const NZERO: ::std::os::raw::c_uint = 0;
pub const NBBY: ::std::os::raw::c_uint = 8;
pub const CMASK: ::std::os::raw::c_uint = 18;
pub const MAXBSIZE: ::std::os::raw::c_uint = 65536;
pub const MAXBCACHEBUF: ::std::os::raw::c_uint = 65536;
pub const BKVASIZE: ::std::os::raw::c_uint = 16384;
pub const BKVAMASK: ::std::os::raw::c_uint = 16383;
pub const MAXPATHLEN: ::std::os::raw::c_uint = 1024;
pub const MAXSYMLINKS: ::std::os::raw::c_uint = 32;
pub const FSHIFT: ::std::os::raw::c_uint = 11;
pub const FSCALE: ::std::os::raw::c_uint = 2048;
pub const KTR_GEN: ::std::os::raw::c_uint = 1;
pub const KTR_NET: ::std::os::raw::c_uint = 2;
pub const KTR_DEV: ::std::os::raw::c_uint = 4;
pub const KTR_LOCK: ::std::os::raw::c_uint = 8;
pub const KTR_SMP: ::std::os::raw::c_uint = 16;
pub const KTR_SUBSYS: ::std::os::raw::c_uint = 32;
pub const KTR_PMAP: ::std::os::raw::c_uint = 64;
pub const KTR_MALLOC: ::std::os::raw::c_uint = 128;
pub const KTR_TRAP: ::std::os::raw::c_uint = 256;
pub const KTR_INTR: ::std::os::raw::c_uint = 512;
pub const KTR_SIG: ::std::os::raw::c_uint = 1024;
pub const KTR_SPARE2: ::std::os::raw::c_uint = 2048;
pub const KTR_PROC: ::std::os::raw::c_uint = 4096;
pub const KTR_SYSC: ::std::os::raw::c_uint = 8192;
pub const KTR_INIT: ::std::os::raw::c_uint = 16384;
pub const KTR_SPARE3: ::std::os::raw::c_uint = 32768;
pub const KTR_SPARE4: ::std::os::raw::c_uint = 65536;
pub const KTR_EVH: ::std::os::raw::c_uint = 131072;
pub const KTR_VFS: ::std::os::raw::c_uint = 262144;
pub const KTR_VOP: ::std::os::raw::c_uint = 524288;
pub const KTR_VM: ::std::os::raw::c_uint = 1048576;
pub const KTR_INET: ::std::os::raw::c_uint = 2097152;
pub const KTR_RUNQ: ::std::os::raw::c_uint = 4194304;
pub const KTR_CONTENTION: ::std::os::raw::c_uint = 8388608;
pub const KTR_UMA: ::std::os::raw::c_uint = 16777216;
pub const KTR_CALLOUT: ::std::os::raw::c_uint = 33554432;
pub const KTR_GEOM: ::std::os::raw::c_uint = 67108864;
pub const KTR_BUSDMA: ::std::os::raw::c_uint = 134217728;
pub const KTR_INET6: ::std::os::raw::c_uint = 268435456;
pub const KTR_SCHED: ::std::os::raw::c_uint = 536870912;
pub const KTR_BUF: ::std::os::raw::c_uint = 1073741824;
pub const KTR_PTRACE: ::std::os::raw::c_uint = 2147483648;
pub const KTR_ALL: ::std::os::raw::c_uint = 4294967295;
pub const KTR_COMPILE: ::std::os::raw::c_uint = 0;
pub const LC_SLEEPLOCK: ::std::os::raw::c_uint = 1;
pub const LC_SPINLOCK: ::std::os::raw::c_uint = 2;
pub const LC_SLEEPABLE: ::std::os::raw::c_uint = 4;
pub const LC_RECURSABLE: ::std::os::raw::c_uint = 8;
pub const LC_UPGRADABLE: ::std::os::raw::c_uint = 16;
pub const LO_CLASSFLAGS: ::std::os::raw::c_uint = 65535;
pub const LO_INITIALIZED: ::std::os::raw::c_uint = 65536;
pub const LO_WITNESS: ::std::os::raw::c_uint = 131072;
pub const LO_QUIET: ::std::os::raw::c_uint = 262144;
pub const LO_RECURSABLE: ::std::os::raw::c_uint = 524288;
pub const LO_SLEEPABLE: ::std::os::raw::c_uint = 1048576;
pub const LO_UPGRADABLE: ::std::os::raw::c_uint = 2097152;
pub const LO_DUPOK: ::std::os::raw::c_uint = 4194304;
pub const LO_IS_VNODE: ::std::os::raw::c_uint = 8388608;
pub const LO_CLASSMASK: ::std::os::raw::c_uint = 251658240;
pub const LO_NOPROFILE: ::std::os::raw::c_uint = 268435456;
pub const LO_NEW: ::std::os::raw::c_uint = 536870912;
pub const LO_CLASSSHIFT: ::std::os::raw::c_uint = 24;
pub const LOCK_CLASS_MAX: ::std::os::raw::c_uint = 15;
pub const LOP_NEWORDER: ::std::os::raw::c_uint = 1;
pub const LOP_QUIET: ::std::os::raw::c_uint = 2;
pub const LOP_TRYLOCK: ::std::os::raw::c_uint = 4;
pub const LOP_EXCLUSIVE: ::std::os::raw::c_uint = 8;
pub const LOP_DUPOK: ::std::os::raw::c_uint = 16;
pub const LA_MASKASSERT: ::std::os::raw::c_uint = 255;
pub const LA_UNLOCKED: ::std::os::raw::c_uint = 0;
pub const LA_LOCKED: ::std::os::raw::c_uint = 1;
pub const LA_SLOCKED: ::std::os::raw::c_uint = 2;
pub const LA_XLOCKED: ::std::os::raw::c_uint = 4;
pub const LA_RECURSED: ::std::os::raw::c_uint = 8;
pub const LA_NOTRECURSED: ::std::os::raw::c_uint = 16;
pub const LOCK_DEBUG: ::std::os::raw::c_uint = 1;
pub const KTR_VERSION: ::std::os::raw::c_uint = 2;
pub const KTR_PARMS: ::std::os::raw::c_uint = 6;
pub const CPU_SETSIZE: ::std::os::raw::c_uint = 256;
pub const CPU_MAXSIZE: ::std::os::raw::c_uint = 256;
pub const PRIO_MIN: ::std::os::raw::c_int = -20;
pub const PRIO_MAX: ::std::os::raw::c_uint = 20;
pub const PRIO_PROCESS: ::std::os::raw::c_uint = 0;
pub const PRIO_PGRP: ::std::os::raw::c_uint = 1;
pub const PRIO_USER: ::std::os::raw::c_uint = 2;
pub const RUSAGE_SELF: ::std::os::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::std::os::raw::c_int = -1;
pub const RUSAGE_THREAD: ::std::os::raw::c_uint = 1;
pub const RLIMIT_CPU: ::std::os::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::std::os::raw::c_uint = 1;
pub const RLIMIT_DATA: ::std::os::raw::c_uint = 2;
pub const RLIMIT_STACK: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CORE: ::std::os::raw::c_uint = 4;
pub const RLIMIT_RSS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::std::os::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::std::os::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::std::os::raw::c_uint = 8;
pub const RLIMIT_SBSIZE: ::std::os::raw::c_uint = 9;
pub const RLIMIT_VMEM: ::std::os::raw::c_uint = 10;
pub const RLIMIT_AS: ::std::os::raw::c_uint = 10;
pub const RLIMIT_NPTS: ::std::os::raw::c_uint = 11;
pub const RLIMIT_SWAP: ::std::os::raw::c_uint = 12;
pub const RLIMIT_KQUEUES: ::std::os::raw::c_uint = 13;
pub const RLIMIT_UMTXP: ::std::os::raw::c_uint = 14;
pub const RLIM_NLIMITS: ::std::os::raw::c_uint = 15;
pub const CP_USER: ::std::os::raw::c_uint = 0;
pub const CP_NICE: ::std::os::raw::c_uint = 1;
pub const CP_SYS: ::std::os::raw::c_uint = 2;
pub const CP_INTR: ::std::os::raw::c_uint = 3;
pub const CP_IDLE: ::std::os::raw::c_uint = 4;
pub const CPUSTATES: ::std::os::raw::c_uint = 5;
pub const PC_DBREG_CMD_NONE: ::std::os::raw::c_uint = 0;
pub const PC_DBREG_CMD_LOAD: ::std::os::raw::c_uint = 1;
pub const OFFSETOF_CURTHREAD: ::std::os::raw::c_uint = 0;
pub const OFFSETOF_CURPCB: ::std::os::raw::c_uint = 32;
pub const DPCPU_SETNAME: &'static [u8; 9usize] = b"set_pcpu\x00";
pub const DPCPU_SYMPREFIX: &'static [u8; 12usize] = b"pcpu_entry_\x00";
pub const DPCPU_MODMIN: ::std::os::raw::c_uint = 2048;
pub const LOCKSTAT_WRITER: ::std::os::raw::c_uint = 0;
pub const LOCKSTAT_READER: ::std::os::raw::c_uint = 1;
pub const MTX_DEF: ::std::os::raw::c_uint = 0;
pub const MTX_SPIN: ::std::os::raw::c_uint = 1;
pub const MTX_RECURSE: ::std::os::raw::c_uint = 4;
pub const MTX_NOWITNESS: ::std::os::raw::c_uint = 8;
pub const MTX_NOPROFILE: ::std::os::raw::c_uint = 32;
pub const MTX_NEW: ::std::os::raw::c_uint = 64;
pub const MTX_QUIET: ::std::os::raw::c_uint = 2;
pub const MTX_DUPOK: ::std::os::raw::c_uint = 16;
pub const MTX_RECURSED: ::std::os::raw::c_uint = 1;
pub const MTX_CONTESTED: ::std::os::raw::c_uint = 2;
pub const MTX_UNOWNED: ::std::os::raw::c_uint = 4;
pub const MTX_FLAGMASK: ::std::os::raw::c_uint = 7;
pub const MTX_DESTROYED: ::std::os::raw::c_uint = 6;
pub const MTX_NETWORK_LOCK: &'static [u8; 15usize] = b"network driver\x00";
pub const EHE_DEAD_PRIORITY: ::std::os::raw::c_int = -1;
pub const EHL_INITTED: ::std::os::raw::c_uint = 1;
pub const EVENTHANDLER_PRI_FIRST: ::std::os::raw::c_uint = 0;
pub const EVENTHANDLER_PRI_ANY: ::std::os::raw::c_uint = 10000;
pub const EVENTHANDLER_PRI_LAST: ::std::os::raw::c_uint = 20000;
pub const SHUTDOWN_PRI_FIRST: ::std::os::raw::c_uint = 0;
pub const SHUTDOWN_PRI_DEFAULT: ::std::os::raw::c_uint = 10000;
pub const SHUTDOWN_PRI_LAST: ::std::os::raw::c_uint = 20000;
pub const LOWMEM_PRI_DEFAULT: ::std::os::raw::c_uint = 0;
pub const SI_ETERNAL: ::std::os::raw::c_uint = 1;
pub const SI_ALIAS: ::std::os::raw::c_uint = 2;
pub const SI_NAMED: ::std::os::raw::c_uint = 4;
pub const SI_CHEAPCLONE: ::std::os::raw::c_uint = 8;
pub const SI_CHILD: ::std::os::raw::c_uint = 16;
pub const SI_DUMPDEV: ::std::os::raw::c_uint = 128;
pub const SI_CLONELIST: ::std::os::raw::c_uint = 512;
pub const SI_UNMAPPED: ::std::os::raw::c_uint = 1024;
pub const SI_NOSPLIT: ::std::os::raw::c_uint = 2048;
pub const D_TAPE: ::std::os::raw::c_uint = 1;
pub const D_DISK: ::std::os::raw::c_uint = 2;
pub const D_TTY: ::std::os::raw::c_uint = 4;
pub const D_MEM: ::std::os::raw::c_uint = 8;
pub const D_TYPEMASK: ::std::os::raw::c_uint = 65535;
pub const D_TRACKCLOSE: ::std::os::raw::c_uint = 524288;
pub const D_MMAP_ANON: ::std::os::raw::c_uint = 1048576;
pub const D_NEEDGIANT: ::std::os::raw::c_uint = 4194304;
pub const D_NEEDMINOR: ::std::os::raw::c_uint = 8388608;
pub const D_VERSION_00: ::std::os::raw::c_uint = 536942950;
pub const D_VERSION_01: ::std::os::raw::c_uint = 386080773;
pub const D_VERSION_02: ::std::os::raw::c_uint = 671358985;
pub const D_VERSION_03: ::std::os::raw::c_uint = 387063817;
pub const D_VERSION: ::std::os::raw::c_uint = 387063817;
pub const D_INIT: ::std::os::raw::c_uint = 2147483648;
pub const CLONE_UNITMASK: ::std::os::raw::c_uint = 1048575;
pub const CLONE_FLAG0: ::std::os::raw::c_uint = 1048576;
pub const MAKEDEV_REF: ::std::os::raw::c_uint = 1;
pub const MAKEDEV_WHTOUT: ::std::os::raw::c_uint = 2;
pub const MAKEDEV_NOWAIT: ::std::os::raw::c_uint = 4;
pub const MAKEDEV_WAITOK: ::std::os::raw::c_uint = 8;
pub const MAKEDEV_ETERNAL: ::std::os::raw::c_uint = 16;
pub const MAKEDEV_CHECKNAME: ::std::os::raw::c_uint = 32;
pub const MAKEDEV_ETERNAL_KLD: ::std::os::raw::c_uint = 0;
pub const UID_ROOT: ::std::os::raw::c_uint = 0;
pub const UID_BIN: ::std::os::raw::c_uint = 3;
pub const UID_UUCP: ::std::os::raw::c_uint = 66;
pub const UID_NOBODY: ::std::os::raw::c_uint = 65534;
pub const GID_WHEEL: ::std::os::raw::c_uint = 0;
pub const GID_KMEM: ::std::os::raw::c_uint = 2;
pub const GID_TTY: ::std::os::raw::c_uint = 4;
pub const GID_OPERATOR: ::std::os::raw::c_uint = 5;
pub const GID_BIN: ::std::os::raw::c_uint = 7;
pub const GID_GAMES: ::std::os::raw::c_uint = 13;
pub const GID_VIDEO: ::std::os::raw::c_uint = 44;
pub const GID_DIALER: ::std::os::raw::c_uint = 68;
pub const GID_NOGROUP: ::std::os::raw::c_uint = 65533;
pub const GID_NOBODY: ::std::os::raw::c_uint = 65534;
pub const UIO_MAXIOV: ::std::os::raw::c_uint = 1024;
pub const M_NOWAIT: ::std::os::raw::c_uint = 1;
pub const M_WAITOK: ::std::os::raw::c_uint = 2;
pub const M_ZERO: ::std::os::raw::c_uint = 256;
pub const M_NOVM: ::std::os::raw::c_uint = 512;
pub const M_USE_RESERVE: ::std::os::raw::c_uint = 1024;
pub const M_NODUMP: ::std::os::raw::c_uint = 2048;
pub const M_FIRSTFIT: ::std::os::raw::c_uint = 4096;
pub const M_BESTFIT: ::std::os::raw::c_uint = 8192;
pub const M_MAGIC: ::std::os::raw::c_uint = 877983977;
pub const DTMALLOC_PROBE_MALLOC: ::std::os::raw::c_uint = 0;
pub const DTMALLOC_PROBE_FREE: ::std::os::raw::c_uint = 1;
pub const DTMALLOC_PROBE_MAX: ::std::os::raw::c_uint = 2;
pub const MALLOC_TYPE_STREAM_VERSION: ::std::os::raw::c_uint = 1;
pub const MALLOC_MAX_NAME: ::std::os::raw::c_uint = 32;
pub const _POSIX_ADVISORY_INFO: ::std::os::raw::c_uint = 200112;
pub const _POSIX_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 200112;
pub const _POSIX_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 1;
pub const _POSIX_CLOCK_SELECTION: ::std::os::raw::c_int = -1;
pub const _POSIX_CPUTIME: ::std::os::raw::c_uint = 200112;
pub const _POSIX_FSYNC: ::std::os::raw::c_uint = 200112;
pub const _POSIX_IPV6: ::std::os::raw::c_uint = 0;
pub const _POSIX_JOB_CONTROL: ::std::os::raw::c_uint = 1;
pub const _POSIX_MAPPED_FILES: ::std::os::raw::c_uint = 200112;
pub const _POSIX_MEMLOCK: ::std::os::raw::c_int = -1;
pub const _POSIX_MEMLOCK_RANGE: ::std::os::raw::c_uint = 200112;
pub const _POSIX_MEMORY_PROTECTION: ::std::os::raw::c_uint = 200112;
pub const _POSIX_MESSAGE_PASSING: ::std::os::raw::c_uint = 200112;
pub const _POSIX_MONOTONIC_CLOCK: ::std::os::raw::c_uint = 200112;
pub const _POSIX_NO_TRUNC: ::std::os::raw::c_uint = 1;
pub const _POSIX_PRIORITIZED_IO: ::std::os::raw::c_int = -1;
pub const _POSIX_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 0;
pub const _POSIX_RAW_SOCKETS: ::std::os::raw::c_uint = 200112;
pub const _POSIX_REALTIME_SIGNALS: ::std::os::raw::c_uint = 200112;
pub const _POSIX_SEMAPHORES: ::std::os::raw::c_uint = 200112;
pub const _POSIX_SHARED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 200112;
pub const _POSIX_SPORADIC_SERVER: ::std::os::raw::c_int = -1;
pub const _POSIX_SYNCHRONIZED_IO: ::std::os::raw::c_int = -1;
pub const _POSIX_TIMEOUTS: ::std::os::raw::c_uint = 200112;
pub const _POSIX_TIMERS: ::std::os::raw::c_uint = 200112;
pub const _POSIX_TYPED_MEMORY_OBJECTS: ::std::os::raw::c_int = -1;
pub const _POSIX_VDISABLE: ::std::os::raw::c_uint = 255;
pub const _XOPEN_SHM: ::std::os::raw::c_uint = 1;
pub const _XOPEN_STREAMS: ::std::os::raw::c_int = -1;
pub const _POSIX_VERSION: ::std::os::raw::c_uint = 200112;
pub const F_OK: ::std::os::raw::c_uint = 0;
pub const X_OK: ::std::os::raw::c_uint = 1;
pub const W_OK: ::std::os::raw::c_uint = 2;
pub const R_OK: ::std::os::raw::c_uint = 4;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const SEEK_DATA: ::std::os::raw::c_uint = 3;
pub const SEEK_HOLE: ::std::os::raw::c_uint = 4;
pub const L_SET: ::std::os::raw::c_uint = 0;
pub const L_INCR: ::std::os::raw::c_uint = 1;
pub const L_XTND: ::std::os::raw::c_uint = 2;
pub const _PC_LINK_MAX: ::std::os::raw::c_uint = 1;
pub const _PC_MAX_CANON: ::std::os::raw::c_uint = 2;
pub const _PC_MAX_INPUT: ::std::os::raw::c_uint = 3;
pub const _PC_NAME_MAX: ::std::os::raw::c_uint = 4;
pub const _PC_PATH_MAX: ::std::os::raw::c_uint = 5;
pub const _PC_PIPE_BUF: ::std::os::raw::c_uint = 6;
pub const _PC_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 7;
pub const _PC_NO_TRUNC: ::std::os::raw::c_uint = 8;
pub const _PC_VDISABLE: ::std::os::raw::c_uint = 9;
pub const _PC_ASYNC_IO: ::std::os::raw::c_uint = 53;
pub const _PC_PRIO_IO: ::std::os::raw::c_uint = 54;
pub const _PC_SYNC_IO: ::std::os::raw::c_uint = 55;
pub const _PC_ALLOC_SIZE_MIN: ::std::os::raw::c_uint = 10;
pub const _PC_FILESIZEBITS: ::std::os::raw::c_uint = 12;
pub const _PC_REC_INCR_XFER_SIZE: ::std::os::raw::c_uint = 14;
pub const _PC_REC_MAX_XFER_SIZE: ::std::os::raw::c_uint = 15;
pub const _PC_REC_MIN_XFER_SIZE: ::std::os::raw::c_uint = 16;
pub const _PC_REC_XFER_ALIGN: ::std::os::raw::c_uint = 17;
pub const _PC_SYMLINK_MAX: ::std::os::raw::c_uint = 18;
pub const _PC_ACL_EXTENDED: ::std::os::raw::c_uint = 59;
pub const _PC_ACL_PATH_MAX: ::std::os::raw::c_uint = 60;
pub const _PC_CAP_PRESENT: ::std::os::raw::c_uint = 61;
pub const _PC_INF_PRESENT: ::std::os::raw::c_uint = 62;
pub const _PC_MAC_PRESENT: ::std::os::raw::c_uint = 63;
pub const _PC_ACL_NFS4: ::std::os::raw::c_uint = 64;
pub const _PC_MIN_HOLE_SIZE: ::std::os::raw::c_uint = 21;
pub const RFNAMEG: ::std::os::raw::c_uint = 1;
pub const RFENVG: ::std::os::raw::c_uint = 2;
pub const RFFDG: ::std::os::raw::c_uint = 4;
pub const RFNOTEG: ::std::os::raw::c_uint = 8;
pub const RFPROC: ::std::os::raw::c_uint = 16;
pub const RFMEM: ::std::os::raw::c_uint = 32;
pub const RFNOWAIT: ::std::os::raw::c_uint = 64;
pub const RFCNAMEG: ::std::os::raw::c_uint = 1024;
pub const RFCENVG: ::std::os::raw::c_uint = 2048;
pub const RFCFDG: ::std::os::raw::c_uint = 4096;
pub const RFTHREAD: ::std::os::raw::c_uint = 8192;
pub const RFSIGSHARE: ::std::os::raw::c_uint = 16384;
pub const RFLINUXTHPN: ::std::os::raw::c_uint = 65536;
pub const RFSTOPPED: ::std::os::raw::c_uint = 131072;
pub const RFHIGHPID: ::std::os::raw::c_uint = 262144;
pub const RFTSIGZMB: ::std::os::raw::c_uint = 524288;
pub const RFTSIGSHIFT: ::std::os::raw::c_uint = 20;
pub const RFTSIGMASK: ::std::os::raw::c_uint = 255;
pub const RFPROCDESC: ::std::os::raw::c_uint = 268435456;
pub const RFPPWAIT: ::std::os::raw::c_uint = 2147483648;
pub const RFFLAGS: ::std::os::raw::c_uint = 2416930932;
pub const RFKERNELONLY: ::std::os::raw::c_uint = 2416312320;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::std::os::raw::c_int;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::std::os::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::std::os::raw::c_int;
pub type __nl_item = ::std::os::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer([u8; 0]);
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq([u8; 0]);
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __cpuwhich_t = ::std::os::raw::c_int;
pub type __cpulevel_t = ::std::os::raw::c_int;
pub type __cpusetid_t = ::std::os::raw::c_int;
pub type __ct_rune_t = ::std::os::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub __max_align1: ::std::os::raw::c_longlong,
    pub __max_align2: f64,
}
impl Clone for _bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
pub type __max_align_t = _bindgen_ty_1;
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
pub union _bindgen_ty_2 {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<_bindgen_ty_2>() , 128usize);
    assert_eq!(::core::mem::align_of::<_bindgen_ty_2>() , 8usize);
}
pub type __mbstate_t = _bindgen_ty_2;
pub type __rman_res_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(::core::mem::size_of::<pthread_once>() , 16usize);
    assert_eq!(::core::mem::align_of::<pthread_once>() , 8usize);
}
impl Clone for pthread_once {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock([u8; 0]);
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::std::os::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr([u8; 0]);
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::std::os::raw::c_void;
pub type pthread_startroutine_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void)
                               -> *mut ::std::os::raw::c_void>;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type c_caddr_t = *const ::std::os::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights([u8; 0]);
pub type cap_rights_t = cap_rights;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_([u8; 0]);
pub type device_t = *mut device_;
pub type boolean_t = ::std::os::raw::c_int;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page([u8; 0]);
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(::core::mem::size_of::<__sigset>() , 16usize);
    assert_eq!(::core::mem::align_of::<__sigset>() , 4usize);
}
impl Clone for __sigset {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::core::mem::size_of::<timeval>() , 16usize);
    assert_eq!(::core::mem::align_of::<timeval>() , 8usize);
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::core::mem::size_of::<timespec>() , 16usize);
    assert_eq!(::core::mem::align_of::<timespec>() , 8usize);
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::core::mem::size_of::<itimerspec>() , 32usize);
    assert_eq!(::core::mem::align_of::<itimerspec>() , 8usize);
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::std::os::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::core::mem::size_of::<fd_set>() , 128usize);
    assert_eq!(::core::mem::align_of::<fd_set>() , 8usize);
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum modeventtype {
    MOD_LOAD = 0,
    MOD_UNLOAD = 1,
    MOD_SHUTDOWN = 2,
    MOD_QUIESCE = 3,
}
pub use self::modeventtype as modeventtype_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module([u8; 0]);
pub type module_t = *mut module;
pub type modeventhand_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: module_t,
                                                arg2: ::std::os::raw::c_int,
                                                arg3:
                                                    *mut ::std::os::raw::c_void)
                               -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct moduledata {
    pub name: *const ::std::os::raw::c_char,
    pub evhand: modeventhand_t,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_moduledata() {
    assert_eq!(::core::mem::size_of::<moduledata>() , 24usize);
    assert_eq!(::core::mem::align_of::<moduledata>() , 8usize);
}
impl Clone for moduledata {
    fn clone(&self) -> Self { *self }
}
pub type moduledata_t = moduledata;
#[repr(C)]
#[derive(Copy)]
pub union modspecific {
    pub intval: ::std::os::raw::c_int,
    pub uintval: u_int,
    pub longval: ::std::os::raw::c_long,
    pub ulongval: u_long,
}
#[test]
fn bindgen_test_layout_modspecific() {
    assert_eq!(::core::mem::size_of::<modspecific>() , 8usize);
    assert_eq!(::core::mem::align_of::<modspecific>() , 8usize);
}
impl Clone for modspecific {
    fn clone(&self) -> Self { *self }
}
pub type modspecific_t = modspecific;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mod_depend {
    pub md_ver_minimum: ::std::os::raw::c_int,
    pub md_ver_preferred: ::std::os::raw::c_int,
    pub md_ver_maximum: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mod_depend() {
    assert_eq!(::core::mem::size_of::<mod_depend>() , 12usize);
    assert_eq!(::core::mem::align_of::<mod_depend>() , 4usize);
}
impl Clone for mod_depend {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mod_version {
    pub mv_version: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mod_version() {
    assert_eq!(::core::mem::size_of::<mod_version>() , 4usize);
    assert_eq!(::core::mem::align_of::<mod_version>() , 4usize);
}
impl Clone for mod_version {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mod_metadata {
    pub md_version: ::std::os::raw::c_int,
    pub md_type: ::std::os::raw::c_int,
    pub md_data: *const ::std::os::raw::c_void,
    pub md_cval: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mod_metadata() {
    assert_eq!(::core::mem::size_of::<mod_metadata>() , 24usize);
    assert_eq!(::core::mem::align_of::<mod_metadata>() , 8usize);
}
impl Clone for mod_metadata {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mod_pnp_match_info {
    pub descr: *const ::std::os::raw::c_char,
    pub bus: *const ::std::os::raw::c_char,
    pub table: *const ::std::os::raw::c_void,
    pub entry_len: ::std::os::raw::c_int,
    pub num_entry: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mod_pnp_match_info() {
    assert_eq!(::core::mem::size_of::<mod_pnp_match_info>() , 32usize);
    assert_eq!(::core::mem::align_of::<mod_pnp_match_info>() , 8usize);
}
impl Clone for mod_pnp_match_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: usize,
}
#[test]
fn bindgen_test_layout_sx() {
    assert_eq!(::core::mem::size_of::<sx>() , 32usize);
    assert_eq!(::core::mem::align_of::<sx>() , 8usize);
}
impl Clone for sx {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "modules_sx"]
    pub static mut modules_sx: sx;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linker_file([u8; 0]);
extern "C" {
    pub fn module_register_init(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn module_register(arg1: *const moduledata, arg2: *mut linker_file)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn module_lookupbyname(arg1: *const ::std::os::raw::c_char)
     -> module_t;
}
extern "C" {
    pub fn module_lookupbyid(arg1: ::std::os::raw::c_int) -> module_t;
}
extern "C" {
    pub fn module_quiesce(arg1: module_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn module_reference(arg1: module_t);
}
extern "C" {
    pub fn module_release(arg1: module_t);
}
extern "C" {
    pub fn module_unload(arg1: module_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn module_getid(arg1: module_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn module_getfnext(arg1: module_t) -> module_t;
}
extern "C" {
    pub fn module_getname(arg1: module_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn module_setspecific(arg1: module_t, arg2: *mut modspecific_t);
}
extern "C" {
    pub fn module_file(arg1: module_t) -> *mut linker_file;
}
#[repr(C)]
#[derive(Copy)]
pub struct module_stat {
    pub version: ::std::os::raw::c_int,
    pub name: [::std::os::raw::c_char; 32usize],
    pub refs: ::std::os::raw::c_int,
    pub id: ::std::os::raw::c_int,
    pub data: modspecific_t,
}
#[test]
fn bindgen_test_layout_module_stat() {
    assert_eq!(::core::mem::size_of::<module_stat>() , 56usize);
    assert_eq!(::core::mem::align_of::<module_stat>() , 8usize);
}
impl Clone for module_stat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn atomic_cmpset_char(dst: *mut u_char, expect: u_char, src: u_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_short(dst: *mut u_short, expect: u_short,
                               src: u_short) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_int(dst: *mut u_int, expect: u_int, src: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_long(dst: *mut u_long, expect: u_long, src: u_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_char(dst: *mut u_char, expect: *mut u_char,
                               src: u_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_short(dst: *mut u_short, expect: *mut u_short,
                                src: u_short) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_int(dst: *mut u_int, expect: *mut u_int, src: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_long(dst: *mut u_long, expect: *mut u_long,
                               src: u_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fetchadd_int(p: *mut u_int, v: u_int) -> u_int;
}
extern "C" {
    pub fn atomic_fetchadd_long(p: *mut u_long, v: u_long) -> u_long;
}
extern "C" {
    pub fn atomic_testandset_int(p: *mut u_int, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_testandset_long(p: *mut u_long, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_int(p: *mut u_int, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_long(p: *mut u_long, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_thread_fence_acq();
}
extern "C" {
    pub fn atomic_thread_fence_acq_rel();
}
extern "C" {
    pub fn atomic_thread_fence_rel();
}
extern "C" {
    pub fn atomic_thread_fence_seq_cst();
}
extern "C" {
    pub fn atomic_set_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_set_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_load_acq_char(p: *mut u_char) -> u_char;
}
extern "C" {
    pub fn atomic_store_rel_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_load_acq_short(p: *mut u_short) -> u_short;
}
extern "C" {
    pub fn atomic_store_rel_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_load_acq_int(p: *mut u_int) -> u_int;
}
extern "C" {
    pub fn atomic_store_rel_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_load_acq_long(p: *mut u_long) -> u_long;
}
extern "C" {
    pub fn atomic_store_rel_long(p: *mut u_long, v: u_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct region_descriptor([u8; 0]);
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct invpcid_descr {
    pub _bitfield_1: u64,
    pub addr: u64,
}
#[test]
fn bindgen_test_layout_invpcid_descr() {
    assert_eq!(::core::mem::size_of::<invpcid_descr>() , 16usize);
    assert_eq!(::core::mem::align_of::<invpcid_descr>() , 1usize);
}
impl Clone for invpcid_descr {
    fn clone(&self) -> Self { *self }
}
impl invpcid_descr {
    #[inline]
    pub fn pcid(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 & (4095usize as u64)) >>
                                        0u32) as u64)
        }
    }
    #[inline]
    pub fn set_pcid(&mut self, val: u64) {
        self._bitfield_1 &= !(4095usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 0u32) & (4095usize as u64);
    }
    #[inline]
    pub fn pad(&self) -> u64 {
        unsafe {
            ::core::mem::transmute(((self._bitfield_1 &
                                         (18446744073709547520usize as u64))
                                        >> 12u32) as u64)
        }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u64) {
        self._bitfield_1 &= !(18446744073709547520usize as u64);
        self._bitfield_1 |=
            ((val as u64 as u64) << 12u32) &
                (18446744073709547520usize as u64);
    }
}
extern "C" {
    pub fn reset_dbregs();
}
extern "C" {
    pub fn rdmsr_safe(msr: u_int, val: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe(msr: u_int, newval: u64) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_object {
    pub lo_name: *const ::std::os::raw::c_char,
    pub lo_flags: u_int,
    pub lo_data: u_int,
    pub lo_witness: *mut lock_object_witness,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_object_witness([u8; 0]);
#[test]
fn bindgen_test_layout_lock_object() {
    assert_eq!(::core::mem::size_of::<lock_object>() , 24usize);
    assert_eq!(::core::mem::align_of::<lock_object>() , 8usize);
}
impl Clone for lock_object {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_list {
    pub lh_first: *mut callout_list_callout,
}
#[repr(C)]
#[derive(Copy)]
pub struct callout_list_callout {
    pub c_links: callout_list_callout__bindgen_ty_1,
    pub c_time: sbintime_t,
    pub c_precision: sbintime_t,
    pub c_arg: *mut ::std::os::raw::c_void,
    pub c_func: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut ::std::os::raw::c_void)>,
    pub c_lock: *mut lock_object,
    pub c_flags: ::std::os::raw::c_short,
    pub c_iflags: ::std::os::raw::c_short,
    pub c_cpu: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy)]
pub union callout_list_callout__bindgen_ty_1 {
    pub le: callout_list_callout__bindgen_ty_1__bindgen_ty_1,
    pub sle: callout_list_callout__bindgen_ty_1__bindgen_ty_2,
    pub tqe: callout_list_callout__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_list_callout__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut callout_list_callout,
    pub le_prev: *mut *mut callout_list_callout,
}
#[test]
fn bindgen_test_layout_callout_list_callout__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<callout_list_callout__bindgen_ty_1__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<callout_list_callout__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for callout_list_callout__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_list_callout__bindgen_ty_1__bindgen_ty_2 {
    pub sle_next: *mut callout_list_callout,
}
#[test]
fn bindgen_test_layout_callout_list_callout__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<callout_list_callout__bindgen_ty_1__bindgen_ty_2>()
               , 8usize);
    assert_eq!(::core::mem::align_of::<callout_list_callout__bindgen_ty_1__bindgen_ty_2>()
               , 8usize);
}
impl Clone for callout_list_callout__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_list_callout__bindgen_ty_1__bindgen_ty_3 {
    pub tqe_next: *mut callout_list_callout,
    pub tqe_prev: *mut *mut callout_list_callout,
}
#[test]
fn bindgen_test_layout_callout_list_callout__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<callout_list_callout__bindgen_ty_1__bindgen_ty_3>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<callout_list_callout__bindgen_ty_1__bindgen_ty_3>()
               , 8usize);
}
impl Clone for callout_list_callout__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_callout_list_callout__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<callout_list_callout__bindgen_ty_1>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<callout_list_callout__bindgen_ty_1>() ,
               8usize);
}
impl Clone for callout_list_callout__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_callout_list_callout() {
    assert_eq!(::core::mem::size_of::<callout_list_callout>() , 64usize);
    assert_eq!(::core::mem::align_of::<callout_list_callout>() , 8usize);
}
impl Clone for callout_list_callout {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_callout_list() {
    assert_eq!(::core::mem::size_of::<callout_list>() , 8usize);
    assert_eq!(::core::mem::align_of::<callout_list>() , 8usize);
}
impl Clone for callout_list {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_slist {
    pub slh_first: *mut callout_list_callout,
}
#[test]
fn bindgen_test_layout_callout_slist() {
    assert_eq!(::core::mem::size_of::<callout_slist>() , 8usize);
    assert_eq!(::core::mem::align_of::<callout_slist>() , 8usize);
}
impl Clone for callout_slist {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_tailq {
    pub tqh_first: *mut callout_list_callout,
    pub tqh_last: *mut *mut callout_list_callout,
}
#[test]
fn bindgen_test_layout_callout_tailq() {
    assert_eq!(::core::mem::size_of::<callout_tailq>() , 16usize);
    assert_eq!(::core::mem::align_of::<callout_tailq>() , 8usize);
}
impl Clone for callout_tailq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_handle {
    pub callout: *mut callout_list_callout,
}
#[test]
fn bindgen_test_layout_callout_handle() {
    assert_eq!(::core::mem::size_of::<callout_handle>() , 8usize);
    assert_eq!(::core::mem::align_of::<callout_handle>() , 8usize);
}
impl Clone for callout_handle {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn callout_init(arg1: *mut callout_list_callout,
                        arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _callout_init_lock(arg1: *mut callout_list_callout,
                              arg2: *mut lock_object,
                              arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn callout_reset_sbt_on(arg1: *mut callout_list_callout,
                                arg2: sbintime_t, arg3: sbintime_t,
                                arg4:
                                    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                    *mut ::std::os::raw::c_void)>,
                                arg5: *mut ::std::os::raw::c_void,
                                arg6: ::std::os::raw::c_int,
                                arg7: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn callout_schedule(arg1: *mut callout_list_callout,
                            arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn callout_schedule_on(arg1: *mut callout_list_callout,
                               arg2: ::std::os::raw::c_int,
                               arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _callout_stop_safe(arg1: *mut callout_list_callout,
                              arg2: ::std::os::raw::c_int,
                              arg3:
                                  ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *mut ::std::os::raw::c_void)>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn callout_process(now: sbintime_t);
}
extern "C" {
    pub fn callout_when(sbt: sbintime_t, precision: sbintime_t,
                        flags: ::std::os::raw::c_int,
                        sbt_res: *mut sbintime_t, prec_res: *mut sbintime_t);
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type uint_fast64_t = __uint_fast64_t;
extern "C" {
    #[link_name = "cold"]
    pub static mut cold: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "suspend_blocked"]
    pub static mut suspend_blocked: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rebooting"]
    pub static mut rebooting: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "panicstr"]
    pub static mut panicstr: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "version"]
    pub static mut version: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "compiler_version"]
    pub static mut compiler_version: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "copyright"]
    pub static mut copyright: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kstack_pages"]
    pub static mut kstack_pages: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "pagesizes"]
    pub static mut pagesizes: [u_long; 0usize];
}
extern "C" {
    #[link_name = "physmem"]
    pub static mut physmem: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "realmem"]
    pub static mut realmem: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "rootdevnames"]
    pub static mut rootdevnames: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "boothowto"]
    pub static mut boothowto: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "bootverbose"]
    pub static mut bootverbose: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "maxusers"]
    pub static mut maxusers: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ngroups_max"]
    pub static mut ngroups_max: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "vm_guest"]
    pub static mut vm_guest: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VM_GUEST {
    VM_GUEST_NO = 0,
    VM_GUEST_VM = 1,
    VM_GUEST_XEN = 2,
    VM_GUEST_HV = 3,
    VM_GUEST_VMWARE = 4,
    VM_GUEST_KVM = 5,
    VM_LAST = 6,
}
extern "C" {
    #[link_name = "osreldate"]
    pub static mut osreldate: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "envmode"]
    pub static mut envmode: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "hintmode"]
    pub static mut hintmode: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "dynamic_kenv"]
    pub static mut dynamic_kenv: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx() {
    assert_eq!(::core::mem::size_of::<mtx>() , 32usize);
    assert_eq!(::core::mem::align_of::<mtx>() , 8usize);
}
impl Clone for mtx {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "kenv_lock"]
    pub static mut kenv_lock: mtx;
}
extern "C" {
    #[link_name = "kern_envp"]
    pub static mut kern_envp: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "static_env"]
    pub static mut static_env: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "static_hints"]
    pub static mut static_hints: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kenvp"]
    pub static mut kenvp: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "zero_region"]
    pub static mut zero_region: *const ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "unmapped_buf_allowed"]
    pub static mut unmapped_buf_allowed: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inpcb([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_type {
    pub ks_next: *mut malloc_type,
    pub ks_magic: u_long,
    pub ks_shortdesc: *const ::std::os::raw::c_char,
    pub ks_handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_malloc_type() {
    assert_eq!(::core::mem::size_of::<malloc_type>() , 32usize);
    assert_eq!(::core::mem::align_of::<malloc_type>() , 8usize);
}
impl Clone for malloc_type {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct socket([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct uio {
    pub uio_iov: *mut iovec,
    pub uio_iovcnt: ::std::os::raw::c_int,
    pub uio_offset: off_t,
    pub uio_resid: isize,
    pub uio_segflg: uio_seg,
    pub uio_rw: uio_rw,
    pub uio_td: *mut thread,
}
#[test]
fn bindgen_test_layout_uio() {
    assert_eq!(::core::mem::size_of::<uio>() , 48usize);
    assert_eq!(::core::mem::align_of::<uio>() , 8usize);
}
impl Clone for uio {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jmp_buf([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trapframe([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventtimer([u8; 0]);
extern "C" {
    pub fn setjmp(arg1: *mut _jmp_buf) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut _jmp_buf, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dumpstatus(addr: vm_offset_t, count: off_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nullop() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eopnotsupp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ureadc(arg1: ::std::os::raw::c_int, arg2: *mut uio)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hashdestroy(arg1: *mut ::std::os::raw::c_void,
                       arg2: *mut malloc_type, arg3: u_long);
}
extern "C" {
    pub fn hashinit(count: ::std::os::raw::c_int, type_: *mut malloc_type,
                    hashmask: *mut u_long) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hashinit_flags(count: ::std::os::raw::c_int,
                          type_: *mut malloc_type, hashmask: *mut u_long,
                          flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn phashinit(count: ::std::os::raw::c_int, type_: *mut malloc_type,
                     nentries: *mut u_long) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn phashinit_flags(count: ::std::os::raw::c_int,
                           type_: *mut malloc_type, nentries: *mut u_long,
                           flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn g_waitidle();
}
extern "C" {
    pub fn panic(arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vpanic(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut __va_list_tag);
}
extern "C" {
    pub fn cpu_boot(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cpu_flush_dcache(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn cpu_rootconf();
}
extern "C" {
    pub fn critical_enter();
}
extern "C" {
    pub fn critical_exit();
}
extern "C" {
    pub fn init_param1();
}
extern "C" {
    pub fn init_param2(physpages: ::std::os::raw::c_long);
}
extern "C" {
    pub fn init_static_kenv(arg1: *mut ::std::os::raw::c_char, arg2: usize);
}
extern "C" {
    pub fn tablefull(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn kvprintf(arg1: *const ::std::os::raw::c_char,
                    arg2:
                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        ::std::os::raw::c_int,
                                                                    arg2:
                                                                        *mut ::std::os::raw::c_void)>,
                    arg3: *mut ::std::os::raw::c_void,
                    arg4: ::std::os::raw::c_int, arg5: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn log(arg1: ::std::os::raw::c_int,
               arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn log_console(arg1: *mut uio);
}
extern "C" {
    pub fn vlog(arg1: ::std::os::raw::c_int,
                arg2: *const ::std::os::raw::c_char,
                arg3: *mut __va_list_tag);
}
extern "C" {
    pub fn asprintf(ret: *mut *mut ::std::os::raw::c_char,
                    mtp: *mut malloc_type,
                    format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                    arg3: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(buf: *mut ::std::os::raw::c_char,
                   arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uprintf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(ret: *mut *mut ::std::os::raw::c_char,
                     mtp: *mut malloc_type,
                     format: *const ::std::os::raw::c_char,
                     ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                     arg3: *const ::std::os::raw::c_char,
                     arg4: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnrprintf(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                      arg3: ::std::os::raw::c_int,
                      arg4: *const ::std::os::raw::c_char,
                      arg5: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(buf: *mut ::std::os::raw::c_char,
                    arg1: *const ::std::os::raw::c_char,
                    arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyprintf(arg1: *mut tty, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtol(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> u_long;
}
extern "C" {
    pub fn strtoq(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> quad_t;
}
extern "C" {
    pub fn strtouq(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> u_quad_t;
}
extern "C" {
    pub fn tprintf(p: *mut proc_, pri: ::std::os::raw::c_int,
                   arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vtprintf(arg1: *mut proc_, arg2: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_char,
                    arg4: *mut __va_list_tag);
}
extern "C" {
    pub fn hexdump(ptr: *const ::std::os::raw::c_void,
                   length: ::std::os::raw::c_int,
                   hdr: *const ::std::os::raw::c_char,
                   flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bcopy(from: *const ::std::os::raw::c_void,
                 to: *mut ::std::os::raw::c_void, len: usize);
}
extern "C" {
    pub fn bzero(buf: *mut ::std::os::raw::c_void, len: usize);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn memcpy(to: *mut ::std::os::raw::c_void,
                  from: *const ::std::os::raw::c_void, len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(dest: *mut ::std::os::raw::c_void,
                   src: *const ::std::os::raw::c_void, n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn copystr(kfaddr: *const ::std::os::raw::c_void,
                   kdaddr: *mut ::std::os::raw::c_void, len: usize,
                   lencopied: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyinstr(udaddr: *const ::std::os::raw::c_void,
                     kaddr: *mut ::std::os::raw::c_void, len: usize,
                     lencopied: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyin(udaddr: *const ::std::os::raw::c_void,
                  kaddr: *mut ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyin_nofault(udaddr: *const ::std::os::raw::c_void,
                          kaddr: *mut ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyout(kaddr: *const ::std::os::raw::c_void,
                   udaddr: *mut ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyout_nofault(kaddr: *const ::std::os::raw::c_void,
                           udaddr: *mut ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fubyte(base: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuword(base: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fuword16(base: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuword32(base: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    pub fn fuword64(base: *const ::std::os::raw::c_void) -> i64;
}
extern "C" {
    pub fn fueword(base: *const ::std::os::raw::c_void,
                   val: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fueword32(base: *const ::std::os::raw::c_void, val: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fueword64(base: *const ::std::os::raw::c_void, val: *mut i64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn subyte(base: *mut ::std::os::raw::c_void,
                  byte: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword(base: *mut ::std::os::raw::c_void,
                  word: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword16(base: *mut ::std::os::raw::c_void,
                    word: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword32(base: *mut ::std::os::raw::c_void, word: i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword64(base: *mut ::std::os::raw::c_void, word: i64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn casuword32(base: *mut u32, oldval: u32, newval: u32) -> u32;
}
extern "C" {
    pub fn casuword(p: *mut u_long, oldval: u_long, newval: u_long) -> u_long;
}
extern "C" {
    pub fn casueword32(base: *mut u32, oldval: u32, oldvalp: *mut u32,
                       newval: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn casueword(p: *mut u_long, oldval: u_long, oldvalp: *mut u_long,
                     newval: u_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realitexpire(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn sysbeep(hertz: ::std::os::raw::c_int,
                   period: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hardclock(usermode: ::std::os::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclock_cnt(cnt: ::std::os::raw::c_int,
                         usermode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hardclock_cpu(usermode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hardclock_sync(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn softclock(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn statclock(usermode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn statclock_cnt(cnt: ::std::os::raw::c_int,
                         usermode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn profclock(usermode: ::std::os::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn profclock_cnt(cnt: ::std::os::raw::c_int,
                         usermode: ::std::os::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclockintr() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn startprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn stopprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn cpu_startprofclock();
}
extern "C" {
    pub fn cpu_stopprofclock();
}
extern "C" {
    pub fn cpu_idleclock() -> sbintime_t;
}
extern "C" {
    pub fn cpu_activeclock();
}
extern "C" {
    pub fn cpu_new_callout(cpu: ::std::os::raw::c_int, bt: sbintime_t,
                           bt_opt: sbintime_t);
}
extern "C" {
    pub fn cpu_et_frequency(et: *mut eventtimer, newfreq: u64);
}
extern "C" {
    #[link_name = "cpu_disable_c2_sleep"]
    pub static mut cpu_disable_c2_sleep: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "cpu_disable_c3_sleep"]
    pub static mut cpu_disable_c3_sleep: ::std::os::raw::c_int;
}
extern "C" {
    pub fn kern_getenv(name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn freeenv(env: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn getenv_int(name: *const ::std::os::raw::c_char,
                      data: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_uint(name: *const ::std::os::raw::c_char,
                       data: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_long(name: *const ::std::os::raw::c_char,
                       data: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_ulong(name: *const ::std::os::raw::c_char,
                        data: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_string(name: *const ::std::os::raw::c_char,
                         data: *mut ::std::os::raw::c_char,
                         size: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_int64(name: *const ::std::os::raw::c_char, data: *mut i64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_uint64(name: *const ::std::os::raw::c_char, data: *mut u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_quad(name: *const ::std::os::raw::c_char, data: *mut quad_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kern_setenv(name: *const ::std::os::raw::c_char,
                       value: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kern_unsetenv(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn testenv(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type cpu_tick_f =
    ::core::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>;
extern "C" {
    pub fn set_cputicker(func: cpu_tick_f, freq: u64,
                         var: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "cpu_ticks"]
    pub static mut cpu_ticks: cpu_tick_f;
}
extern "C" {
    pub fn cpu_tickrate() -> u64;
}
extern "C" {
    pub fn cputick2usec(tick: u64) -> u64;
}
extern "C" {
    #[link_name = "bcd2bin_data"]
    pub static mut bcd2bin_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "bin2bcd_data"]
    pub static mut bin2bcd_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "hex2ascii_data"]
    pub static mut hex2ascii_data: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "arc4rand_iniseed_state"]
    pub static mut arc4rand_iniseed_state: ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn arc4rand(arg1: *mut ::std::os::raw::c_void, arg2: u_int,
                    arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bcmp(arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timingsafe_bcmp(arg1: *const ::std::os::raw::c_void,
                           arg2: *const ::std::os::raw::c_void, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch(arg1: *const ::std::os::raw::c_void,
                   arg2: *const ::std::os::raw::c_void, arg3: usize,
                   arg4: usize,
                   arg5:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn fnmatch(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn locc(arg1: ::std::os::raw::c_int,
                arg2: *mut ::std::os::raw::c_char, arg3: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(s: *const ::std::os::raw::c_void, c: ::std::os::raw::c_int,
                  n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcchr(s: *const ::std::os::raw::c_void, c: ::std::os::raw::c_int,
                   n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(b1: *const ::std::os::raw::c_void,
                  b2: *const ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memmem(l: *const ::std::os::raw::c_void, l_len: usize,
                  s: *const ::std::os::raw::c_void, s_len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(base: *mut ::std::os::raw::c_void, nmemb: usize, size: usize,
                 compar:
                     ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *const ::std::os::raw::c_void,
                                                                 arg2:
                                                                     *const ::std::os::raw::c_void)
                                                -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn qsort_r(base: *mut ::std::os::raw::c_void, nmemb: usize,
                   size: usize, thunk: *mut ::std::os::raw::c_void,
                   compar:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg3:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn random() -> u_long;
}
extern "C" {
    pub fn scanc(arg1: u_int, arg2: *const u_char, arg3: *const u_char,
                 arg4: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom(arg1: u_long);
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcat(arg1: *mut ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const ::std::os::raw::c_char,
                  arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strdup(arg1: *const ::std::os::raw::c_char, arg2: *mut malloc_type)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const ::std::os::raw::c_char, arg2: usize,
                   arg3: *mut malloc_type) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn strlcpy(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strncasecmp(arg1: *const ::std::os::raw::c_char,
                       arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strrchr(arg1: *const ::std::os::raw::c_char,
                   arg2: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut ::std::os::raw::c_char,
                  delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strstr(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strvalid(arg1: *const ::std::os::raw::c_char, arg2: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "crc32_tab"]
    pub static mut crc32_tab: [u32; 0usize];
}
extern "C" {
    pub fn calculate_crc32c(crc32c: u32,
                            buffer: *const ::std::os::raw::c_uchar,
                            length: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn sse42_crc32c(arg1: u32, arg2: *const ::std::os::raw::c_uchar,
                        arg3: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn consinit();
}
extern "C" {
    pub fn cpu_initclocks();
}
extern "C" {
    pub fn cpu_initclocks_bsp();
}
extern "C" {
    pub fn cpu_initclocks_ap();
}
extern "C" {
    pub fn usrinfoinit();
}
extern "C" {
    pub fn kern_reboot(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn shutdown_nice(arg1: ::std::os::raw::c_int);
}
pub type timeout_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn callout_handle_init(arg1: *mut callout_handle);
}
extern "C" {
    pub fn timeout(arg1: timeout_t, arg2: *mut ::std::os::raw::c_void,
                   arg3: ::std::os::raw::c_int) -> callout_handle;
}
extern "C" {
    pub fn untimeout(arg1: timeout_t, arg2: *mut ::std::os::raw::c_void,
                     arg3: callout_handle);
}
extern "C" {
    pub fn _sleep(chan: *mut ::std::os::raw::c_void, lock: *mut lock_object,
                  pri: ::std::os::raw::c_int,
                  wmesg: *const ::std::os::raw::c_char, sbt: sbintime_t,
                  pr: sbintime_t, flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msleep_spin_sbt(chan: *mut ::std::os::raw::c_void, mtx: *mut mtx,
                           wmesg: *const ::std::os::raw::c_char,
                           sbt: sbintime_t, pr: sbintime_t,
                           flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause_sbt(wmesg: *const ::std::os::raw::c_char, sbt: sbintime_t,
                     pr: sbintime_t, flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wakeup(chan: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wakeup_one(chan: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct cdev {
    pub si_spare0: *mut ::std::os::raw::c_void,
    pub si_flags: u_int,
    pub si_atime: timespec,
    pub si_ctime: timespec,
    pub si_mtime: timespec,
    pub si_uid: uid_t,
    pub si_gid: gid_t,
    pub si_mode: mode_t,
    pub si_cred: *mut ucred,
    pub si_drv0: ::std::os::raw::c_int,
    pub si_refcount: ::std::os::raw::c_int,
    pub si_list: cdev__bindgen_ty_1,
    pub si_clone: cdev__bindgen_ty_2,
    pub si_children: cdev__bindgen_ty_3,
    pub si_siblings: cdev__bindgen_ty_4,
    pub si_parent: *mut cdev,
    pub si_mountpt: *mut mount,
    pub si_drv1: *mut ::std::os::raw::c_void,
    pub si_drv2: *mut ::std::os::raw::c_void,
    pub si_devsw: *mut cdevsw,
    pub si_iosize_max: ::std::os::raw::c_int,
    pub si_usecount: u_long,
    pub si_threadcount: u_long,
    pub __si_u: cdev__bindgen_ty_5,
    pub si_name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdev__bindgen_ty_1 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<cdev__bindgen_ty_1>() , 16usize);
    assert_eq!(::core::mem::align_of::<cdev__bindgen_ty_1>() , 8usize);
}
impl Clone for cdev__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdev__bindgen_ty_2 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<cdev__bindgen_ty_2>() , 16usize);
    assert_eq!(::core::mem::align_of::<cdev__bindgen_ty_2>() , 8usize);
}
impl Clone for cdev__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdev__bindgen_ty_3 {
    pub lh_first: *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<cdev__bindgen_ty_3>() , 8usize);
    assert_eq!(::core::mem::align_of::<cdev__bindgen_ty_3>() , 8usize);
}
impl Clone for cdev__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdev__bindgen_ty_4 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<cdev__bindgen_ty_4>() , 16usize);
    assert_eq!(::core::mem::align_of::<cdev__bindgen_ty_4>() , 8usize);
}
impl Clone for cdev__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union cdev__bindgen_ty_5 {
    pub __sid_snapdata: *mut snapdata,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<cdev__bindgen_ty_5>() , 8usize);
    assert_eq!(::core::mem::align_of::<cdev__bindgen_ty_5>() , 8usize);
}
impl Clone for cdev__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_cdev() {
    assert_eq!(::core::mem::size_of::<cdev>() , 288usize);
    assert_eq!(::core::mem::align_of::<cdev>() , 8usize);
}
extern "C" {
    pub fn dev2udev(x: *mut cdev) -> dev_t;
}
extern "C" {
    pub fn devtoname(cdev: *mut cdev) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn devfs_iosize_max() -> usize;
}
extern "C" {
    pub fn iosize_max() -> usize;
}
extern "C" {
    pub fn poll_no_poll(events: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DELAY(usec: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct root_hold_token([u8; 0]);
extern "C" {
    pub fn root_mount_hold(identifier: *const ::std::os::raw::c_char)
     -> *mut root_hold_token;
}
extern "C" {
    pub fn root_mount_rel(h: *mut root_hold_token);
}
extern "C" {
    pub fn root_mounted() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unrhdr([u8; 0]);
extern "C" {
    pub fn new_unrhdr(low: ::std::os::raw::c_int, high: ::std::os::raw::c_int,
                      mutex: *mut mtx) -> *mut unrhdr;
}
extern "C" {
    pub fn init_unrhdr(uh: *mut unrhdr, low: ::std::os::raw::c_int,
                       high: ::std::os::raw::c_int, mutex: *mut mtx);
}
extern "C" {
    pub fn delete_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdrl(uh: *mut unrhdr);
}
extern "C" {
    pub fn alloc_unr(uh: *mut unrhdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alloc_unr_specific(uh: *mut unrhdr, item: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alloc_unrl(uh: *mut unrhdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free_unr(uh: *mut unrhdr, item: u_int);
}
extern "C" {
    pub fn intr_prof_stack_use(td: *mut thread, frame: *mut trapframe);
}
extern "C" {
    pub fn counted_warning(counter: *mut ::std::os::raw::c_uint,
                           msg: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::core::mem::size_of::<timezone>() , 8usize);
    assert_eq!(::core::mem::align_of::<timezone>() , 4usize);
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(::core::mem::size_of::<bintime>() , 16usize);
    assert_eq!(::core::mem::align_of::<bintime>() , 8usize);
}
impl Clone for bintime {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::core::mem::size_of::<itimerval>() , 32usize);
    assert_eq!(::core::mem::align_of::<itimerval>() , 8usize);
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub spare: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(::core::mem::size_of::<clockinfo>() , 20usize);
    assert_eq!(::core::mem::align_of::<clockinfo>() , 4usize);
}
impl Clone for clockinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn inittodr(base: time_t);
}
extern "C" {
    pub fn resettodr();
}
extern "C" {
    #[link_name = "time_second"]
    pub static mut time_second: time_t;
}
extern "C" {
    #[link_name = "time_uptime"]
    pub static mut time_uptime: time_t;
}
extern "C" {
    #[link_name = "tc_tick_bt"]
    pub static mut tc_tick_bt: bintime;
}
extern "C" {
    #[link_name = "tc_tick_sbt"]
    pub static mut tc_tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tick_bt"]
    pub static mut tick_bt: bintime;
}
extern "C" {
    #[link_name = "tick_sbt"]
    pub static mut tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tc_precexp"]
    pub static mut tc_precexp: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "tc_timepercentage"]
    pub static mut tc_timepercentage: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "bt_timethreshold"]
    pub static mut bt_timethreshold: bintime;
}
extern "C" {
    #[link_name = "bt_tickthreshold"]
    pub static mut bt_tickthreshold: bintime;
}
extern "C" {
    #[link_name = "sbt_timethreshold"]
    pub static mut sbt_timethreshold: sbintime_t;
}
extern "C" {
    #[link_name = "sbt_tickthreshold"]
    pub static mut sbt_tickthreshold: sbintime_t;
}
extern "C" {
    #[link_name = "rtc_generation"]
    pub static mut rtc_generation: ::std::os::raw::c_int;
}
extern "C" {
    pub fn binuptime(bt: *mut bintime);
}
extern "C" {
    pub fn nanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn microuptime(tvp: *mut timeval);
}
extern "C" {
    pub fn bintime(bt: *mut bintime);
}
extern "C" {
    pub fn nanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn microtime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbinuptime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrouptime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbintime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrotime(tvp: *mut timeval);
}
extern "C" {
    pub fn getboottime(boottime: *mut timeval);
}
extern "C" {
    pub fn getboottimebin(boottimebin: *mut bintime);
}
extern "C" {
    pub fn itimerdecr(itp: *mut itimerval, usec: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn itimerfix(tv: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ppsratecheck(arg1: *mut timeval, arg2: *mut ::std::os::raw::c_int,
                        arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn tvtohz(tv: *mut timeval) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
#[test]
fn bindgen_test_layout_priority() {
    assert_eq!(::core::mem::size_of::<priority>() , 4usize);
    assert_eq!(::core::mem::align_of::<priority>() , 1usize);
}
impl Clone for priority {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    #[link_name = "kernelname"]
    pub static mut kernelname: [::std::os::raw::c_char; 1024usize];
}
extern "C" {
    #[link_name = "tick"]
    pub static mut tick: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "hz"]
    pub static mut hz: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "psratio"]
    pub static mut psratio: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "stathz"]
    pub static mut stathz: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "profhz"]
    pub static mut profhz: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "profprocs"]
    pub static mut profprocs: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ticks"]
    pub static mut ticks: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sysinit_sub_id {
    SI_SUB_DUMMY = 0,
    SI_SUB_DONE = 1,
    SI_SUB_TUNABLES = 7340032,
    SI_SUB_COPYRIGHT = 8388609,
    SI_SUB_VM = 16777216,
    SI_SUB_KMEM = 25165824,
    SI_SUB_HYPERVISOR = 27525120,
    SI_SUB_WITNESS = 27787264,
    SI_SUB_MTX_POOL_DYNAMIC = 28049408,
    SI_SUB_LOCK = 28311552,
    SI_SUB_EVENTHANDLER = 29360128,
    SI_SUB_VNET_PRELINK = 31457280,
    SI_SUB_KLD = 33554432,
    SI_SUB_CPU = 34603008,
    SI_SUB_RACCT = 34668544,
    SI_SUB_KDTRACE = 34865152,
    SI_SUB_RANDOM = 34996224,
    SI_SUB_MAC = 35127296,
    SI_SUB_MAC_POLICY = 35389440,
    SI_SUB_MAC_LATE = 35454976,
    SI_SUB_VNET = 35520512,
    SI_SUB_INTRINSIC = 35651584,
    SI_SUB_VM_CONF = 36700160,
    SI_SUB_DDB_SERVICES = 37224448,
    SI_SUB_RUN_QUEUE = 37748736,
    SI_SUB_KTRACE = 38273024,
    SI_SUB_OPENSOLARIS = 38338560,
    SI_SUB_AUDIT = 38535168,
    SI_SUB_CREATE_INIT = 38797312,
    SI_SUB_SCHED_IDLE = 39845888,
    SI_SUB_MBUF = 40894464,
    SI_SUB_INTR = 41943040,
    SI_SUB_SOFTINTR = 44040192,
    SI_SUB_DEVFS = 49283072,
    SI_SUB_INIT_IF = 50331648,
    SI_SUB_NETGRAPH = 50397184,
    SI_SUB_DTRACE = 50462720,
    SI_SUB_DTRACE_PROVIDER = 50626560,
    SI_SUB_DTRACE_ANON = 50905088,
    SI_SUB_DRIVERS = 51380224,
    SI_SUB_CONFIGURE = 58720256,
    SI_SUB_VFS = 67108864,
    SI_SUB_CLOCKS = 75497472,
    SI_SUB_SYSV_SHM = 104857600,
    SI_SUB_SYSV_SEM = 109051904,
    SI_SUB_SYSV_MSG = 113246208,
    SI_SUB_P1003_1B = 115343360,
    SI_SUB_PSEUDO = 117440512,
    SI_SUB_EXEC = 121634816,
    SI_SUB_PROTO_BEGIN = 134217728,
    SI_SUB_PROTO_PFIL = 135266304,
    SI_SUB_PROTO_IF = 138412032,
    SI_SUB_PROTO_DOMAININIT = 140509184,
    SI_SUB_PROTO_MC = 141557760,
    SI_SUB_PROTO_DOMAIN = 142606336,
    SI_SUB_PROTO_FIREWALL = 142630912,
    SI_SUB_PROTO_IFATTACHDOMAIN = 142639104,
    SI_SUB_PROTO_END = 150994943,
    SI_SUB_KPROF = 150994944,
    SI_SUB_KICK_SCHEDULER = 167772160,
    SI_SUB_INT_CONFIG_HOOKS = 176160768,
    SI_SUB_ROOT_CONF = 184549376,
    SI_SUB_INTRINSIC_POST = 218103808,
    SI_SUB_SYSCALLS = 226492416,
    SI_SUB_VNET_DONE = 230686720,
    SI_SUB_KTHREAD_INIT = 234881024,
    SI_SUB_KTHREAD_PAGE = 239075328,
    SI_SUB_KTHREAD_VM = 243269632,
    SI_SUB_KTHREAD_BUF = 245366784,
    SI_SUB_KTHREAD_UPDATE = 247463936,
    SI_SUB_KTHREAD_IDLE = 249561088,
    SI_SUB_SMP = 251658240,
    SI_SUB_RACCTD = 252706816,
    SI_SUB_LAST = 268435455,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sysinit_elem_order {
    SI_ORDER_FIRST = 0,
    SI_ORDER_SECOND = 1,
    SI_ORDER_THIRD = 2,
    SI_ORDER_FOURTH = 3,
    SI_ORDER_MIDDLE = 16777216,
    SI_ORDER_ANY = 268435455,
}
pub type sysinit_nfunc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void)>;
pub type sysinit_cfunc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *const ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysinit {
    pub subsystem: sysinit_sub_id,
    pub order: sysinit_elem_order,
    pub func: sysinit_cfunc_t,
    pub udata: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sysinit() {
    assert_eq!(::core::mem::size_of::<sysinit>() , 24usize);
    assert_eq!(::core::mem::align_of::<sysinit>() , 8usize);
}
impl Clone for sysinit {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sysinit_add(set: *mut *mut sysinit, set_end: *mut *mut sysinit);
}
extern "C" {
    pub fn tunable_int_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_int {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tunable_int() {
    assert_eq!(::core::mem::size_of::<tunable_int>() , 16usize);
    assert_eq!(::core::mem::align_of::<tunable_int>() , 8usize);
}
impl Clone for tunable_int {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn tunable_long_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_long {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_tunable_long() {
    assert_eq!(::core::mem::size_of::<tunable_long>() , 16usize);
    assert_eq!(::core::mem::align_of::<tunable_long>() , 8usize);
}
impl Clone for tunable_long {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn tunable_ulong_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_ulong {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_tunable_ulong() {
    assert_eq!(::core::mem::size_of::<tunable_ulong>() , 16usize);
    assert_eq!(::core::mem::align_of::<tunable_ulong>() , 8usize);
}
impl Clone for tunable_ulong {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn tunable_int64_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_int64 {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut i64,
}
#[test]
fn bindgen_test_layout_tunable_int64() {
    assert_eq!(::core::mem::size_of::<tunable_int64>() , 16usize);
    assert_eq!(::core::mem::align_of::<tunable_int64>() , 8usize);
}
impl Clone for tunable_int64 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn tunable_uint64_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_uint64 {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut u64,
}
#[test]
fn bindgen_test_layout_tunable_uint64() {
    assert_eq!(::core::mem::size_of::<tunable_uint64>() , 16usize);
    assert_eq!(::core::mem::align_of::<tunable_uint64>() , 8usize);
}
impl Clone for tunable_uint64 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn tunable_quad_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_quad {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut quad_t,
}
#[test]
fn bindgen_test_layout_tunable_quad() {
    assert_eq!(::core::mem::size_of::<tunable_quad>() , 16usize);
    assert_eq!(::core::mem::align_of::<tunable_quad>() , 8usize);
}
impl Clone for tunable_quad {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn tunable_str_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_str {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut ::std::os::raw::c_char,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tunable_str() {
    assert_eq!(::core::mem::size_of::<tunable_str>() , 24usize);
    assert_eq!(::core::mem::align_of::<tunable_str>() , 8usize);
}
impl Clone for tunable_str {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct intr_config_hook {
    pub ich_links: intr_config_hook__bindgen_ty_1,
    pub ich_func: ::core::option::Option<unsafe extern "C" fn(arg:
                                                                  *mut ::std::os::raw::c_void)>,
    pub ich_arg: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct intr_config_hook__bindgen_ty_1 {
    pub tqe_next: *mut intr_config_hook,
    pub tqe_prev: *mut *mut intr_config_hook,
}
#[test]
fn bindgen_test_layout_intr_config_hook__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<intr_config_hook__bindgen_ty_1>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<intr_config_hook__bindgen_ty_1>() ,
               8usize);
}
impl Clone for intr_config_hook__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_intr_config_hook() {
    assert_eq!(::core::mem::size_of::<intr_config_hook>() , 32usize);
    assert_eq!(::core::mem::align_of::<intr_config_hook>() , 8usize);
}
impl Clone for intr_config_hook {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn config_intrhook_establish(hook: *mut intr_config_hook)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn config_intrhook_disestablish(hook: *mut intr_config_hook);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_list_entry([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_class {
    pub lc_name: *const ::std::os::raw::c_char,
    pub lc_flags: u_int,
    pub lc_assert: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                   *const lock_object,
                                                               what:
                                                                   ::std::os::raw::c_int)>,
    pub lc_ddb_show: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                     *const lock_object)>,
    pub lc_lock: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                 *mut lock_object,
                                                             how: usize)>,
    pub lc_owner: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                  *const lock_object,
                                                              owner:
                                                                  *mut *mut thread)
                                             -> ::std::os::raw::c_int>,
    pub lc_unlock: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                   *mut lock_object)
                                              -> ::std::os::raw::c_ulong>,
}
#[test]
fn bindgen_test_layout_lock_class() {
    assert_eq!(::core::mem::size_of::<lock_class>() , 56usize);
    assert_eq!(::core::mem::align_of::<lock_class>() , 8usize);
}
impl Clone for lock_class {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "lock_class_mtx_sleep"]
    pub static mut lock_class_mtx_sleep: lock_class;
}
extern "C" {
    #[link_name = "lock_class_mtx_spin"]
    pub static mut lock_class_mtx_spin: lock_class;
}
extern "C" {
    #[link_name = "lock_class_sx"]
    pub static mut lock_class_sx: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rw"]
    pub static mut lock_class_rw: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm"]
    pub static mut lock_class_rm: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm_sleepable"]
    pub static mut lock_class_rm_sleepable: lock_class;
}
extern "C" {
    #[link_name = "lock_class_lockmgr"]
    pub static mut lock_class_lockmgr: lock_class;
}
extern "C" {
    #[link_name = "lock_classes"]
    pub static mut lock_classes: [*mut lock_class; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_delay_config {
    pub base: u_int,
    pub max: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_config() {
    assert_eq!(::core::mem::size_of::<lock_delay_config>() , 8usize);
    assert_eq!(::core::mem::align_of::<lock_delay_config>() , 4usize);
}
impl Clone for lock_delay_config {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_delay_arg {
    pub config: *mut lock_delay_config,
    pub delay: u_int,
    pub spin_cnt: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_arg() {
    assert_eq!(::core::mem::size_of::<lock_delay_arg>() , 16usize);
    assert_eq!(::core::mem::align_of::<lock_delay_arg>() , 8usize);
}
impl Clone for lock_delay_arg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lock_init(arg1: *mut lock_object, arg2: *mut lock_class,
                     arg3: *const ::std::os::raw::c_char,
                     arg4: *const ::std::os::raw::c_char,
                     arg5: ::std::os::raw::c_int);
}
extern "C" {
    pub fn lock_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn lock_delay(arg1: *mut lock_delay_arg);
}
extern "C" {
    pub fn lock_delay_default_init(arg1: *mut lock_delay_config);
}
extern "C" {
    pub fn spinlock_enter();
}
extern "C" {
    pub fn spinlock_exit();
}
extern "C" {
    pub fn witness_init(arg1: *mut lock_object,
                        arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn witness_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_defineorder(arg1: *mut lock_object, arg2: *mut lock_object)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_checkorder(arg1: *mut lock_object,
                              arg2: ::std::os::raw::c_int,
                              arg3: *const ::std::os::raw::c_char,
                              arg4: ::std::os::raw::c_int,
                              arg5: *mut lock_object);
}
extern "C" {
    pub fn witness_lock(arg1: *mut lock_object, arg2: ::std::os::raw::c_int,
                        arg3: *const ::std::os::raw::c_char,
                        arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_upgrade(arg1: *mut lock_object,
                           arg2: ::std::os::raw::c_int,
                           arg3: *const ::std::os::raw::c_char,
                           arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_downgrade(arg1: *mut lock_object,
                             arg2: ::std::os::raw::c_int,
                             arg3: *const ::std::os::raw::c_char,
                             arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_unlock(arg1: *mut lock_object, arg2: ::std::os::raw::c_int,
                          arg3: *const ::std::os::raw::c_char,
                          arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_save(arg1: *mut lock_object,
                        arg2: *mut *const ::std::os::raw::c_char,
                        arg3: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_restore(arg1: *mut lock_object,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_list_locks(arg1: *mut *mut lock_list_entry,
                              arg2:
                                  ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const ::std::os::raw::c_char, ...)
                                                             ->
                                                                 ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_warn(arg1: ::std::os::raw::c_int, arg2: *mut lock_object,
                        arg3: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_assert(arg1: *const lock_object,
                          arg2: ::std::os::raw::c_int,
                          arg3: *const ::std::os::raw::c_char,
                          arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_display_spinlock(arg1: *mut lock_object, arg2: *mut thread,
                                    arg3:
                                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                        *const ::std::os::raw::c_char, ...)
                                                                   ->
                                                                       ::std::os::raw::c_int>);
}
extern "C" {
    pub fn witness_line(arg1: *mut lock_object) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_norelease(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_releaseok(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_file(arg1: *mut lock_object)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn witness_thread_exit(arg1: *mut thread);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cpuset {
    pub __bits: [::std::os::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout__cpuset() {
    assert_eq!(::core::mem::size_of::<_cpuset>() , 32usize);
    assert_eq!(::core::mem::align_of::<_cpuset>() , 8usize);
}
impl Clone for _cpuset {
    fn clone(&self) -> Self { *self }
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ktr_entry {
    pub ktr_timestamp: u_int64_t,
    pub ktr_cpu: ::std::os::raw::c_int,
    pub ktr_line: ::std::os::raw::c_int,
    pub ktr_file: *const ::std::os::raw::c_char,
    pub ktr_desc: *const ::std::os::raw::c_char,
    pub ktr_thread: *mut thread,
    pub ktr_parms: [u_long; 6usize],
}
#[test]
fn bindgen_test_layout_ktr_entry() {
    assert_eq!(::core::mem::size_of::<ktr_entry>() , 88usize);
    assert_eq!(::core::mem::align_of::<ktr_entry>() , 8usize);
}
impl Clone for ktr_entry {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ktr_cpumask"]
    pub static mut ktr_cpumask: cpuset_t;
}
extern "C" {
    #[link_name = "ktr_mask"]
    pub static mut ktr_mask: u64;
}
extern "C" {
    #[link_name = "ktr_entries"]
    pub static mut ktr_entries: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_verbose"]
    pub static mut ktr_verbose: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_idx"]
    pub static mut ktr_idx: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_buf"]
    pub static mut ktr_buf: *mut ktr_entry;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
impl Clone for mtx_padalign {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmpriolist {
    pub lh_first: *mut rmpriolist_rm_priotracker,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmpriolist_rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: ::std::os::raw::c_int,
    pub rmp_qentry: rmpriolist_rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmpriolist_rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rmpriolist_rm_priotracker,
    pub le_prev: *mut *mut rmpriolist_rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmpriolist_rm_priotracker__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rmpriolist_rm_priotracker__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::core::mem::align_of::<rmpriolist_rm_priotracker__bindgen_ty_1>()
               , 8usize);
}
impl Clone for rmpriolist_rm_priotracker__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rmpriolist_rm_priotracker() {
    assert_eq!(::core::mem::size_of::<rmpriolist_rm_priotracker>() , 56usize);
    assert_eq!(::core::mem::align_of::<rmpriolist_rm_priotracker>() , 8usize);
}
impl Clone for rmpriolist_rm_priotracker {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rmpriolist() {
    assert_eq!(::core::mem::size_of::<rmpriolist>() , 8usize);
    assert_eq!(::core::mem::align_of::<rmpriolist>() , 8usize);
}
impl Clone for rmpriolist {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
#[test]
fn bindgen_test_layout_rm_queue() {
    assert_eq!(::core::mem::size_of::<rm_queue>() , 16usize);
    assert_eq!(::core::mem::align_of::<rm_queue>() , 8usize);
}
impl Clone for rm_queue {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rmpriolist_rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_1>() , 8usize);
    assert_eq!(::core::mem::align_of::<rmlock__bindgen_ty_1>() , 8usize);
}
impl Clone for rmlock__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: lock_object,
    pub _rm_lock_mtx: mtx,
    pub _rm_lock_sx: sx,
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_2>() , 32usize);
    assert_eq!(::core::mem::align_of::<rmlock__bindgen_ty_2>() , 8usize);
}
impl Clone for rmlock__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rmlock() {
    assert_eq!(::core::mem::size_of::<rmlock>() , 96usize);
    assert_eq!(::core::mem::align_of::<rmlock>() , 8usize);
}
impl Clone for rmlock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::core::mem::size_of::<rusage>() , 144usize);
    assert_eq!(::core::mem::align_of::<rusage>() , 8usize);
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[test]
fn bindgen_test_layout___wrusage() {
    assert_eq!(::core::mem::size_of::<__wrusage>() , 288usize);
    assert_eq!(::core::mem::align_of::<__wrusage>() , 8usize);
}
impl Clone for __wrusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::core::mem::size_of::<rlimit>() , 16usize);
    assert_eq!(::core::mem::align_of::<rlimit>() , 8usize);
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[test]
fn bindgen_test_layout_orlimit() {
    assert_eq!(::core::mem::size_of::<orlimit>() , 8usize);
    assert_eq!(::core::mem::align_of::<orlimit>() , 4usize);
}
impl Clone for orlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(::core::mem::size_of::<loadavg>() , 24usize);
    assert_eq!(::core::mem::align_of::<loadavg>() , 8usize);
}
impl Clone for loadavg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "averunnable"]
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn read_cpu_time(cp_time: *mut ::std::os::raw::c_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcb([u8; 0]);
extern "C" {
    #[link_name = "__start_set_pcpu"]
    pub static mut __start_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "__stop_set_pcpu"]
    pub static mut __stop_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "dpcpu_off"]
    pub static mut dpcpu_off: [usize; 0usize];
}
#[repr(C)]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_switchtime: u64,
    pub pc_switchticks: ::std::os::raw::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [::std::os::raw::c_long; 5usize],
    pub pc_device: *mut device_,
    pub pc_netisr: *mut ::std::os::raw::c_void,
    pub pc_unused1: ::std::os::raw::c_int,
    pub pc_domain: ::std::os::raw::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub pc_monitorbuf: [::std::os::raw::c_char; 128usize],
    pub pc_prvspace: *mut pcpu,
    pub pc_curpmap: *mut pcpu_pmap,
    pub pc_tssp: *mut pcpu_amd64tss,
    pub pc_commontssp: *mut pcpu_amd64tss,
    pub pc_rsp0: register_t,
    pub pc_scratch_rsp: register_t,
    pub pc_apic_id: u_int,
    pub pc_acpi_id: u_int,
    pub pc_fs32p: *mut pcpu_user_segment_descriptor,
    pub pc_gs32p: *mut pcpu_user_segment_descriptor,
    pub pc_ldt: *mut pcpu_system_segment_descriptor,
    pub pc_tss: *mut pcpu_system_segment_descriptor,
    pub pc_pm_save_cnt: u64,
    pub pc_cmci_mask: u_int,
    pub pc_dbreg: [u64; 16usize],
    pub pc_dbreg_cmd: ::std::os::raw::c_int,
    pub pc_vcpu_id: u_int,
    pub pc_pcid_next: u32,
    pub pc_pcid_gen: u32,
    pub pc_smp_tlb_done: u32,
    pub __pad: [::std::os::raw::c_char; 384usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
#[test]
fn bindgen_test_layout_pcpu__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pcpu__bindgen_ty_1>() , 8usize);
    assert_eq!(::core::mem::align_of::<pcpu__bindgen_ty_1>() , 8usize);
}
impl Clone for pcpu__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_pmap([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_amd64tss([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_user_segment_descriptor([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_system_segment_descriptor([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
#[test]
fn bindgen_test_layout_cpuhead() {
    assert_eq!(::core::mem::size_of::<cpuhead>() , 16usize);
    assert_eq!(::core::mem::align_of::<cpuhead>() , 8usize);
}
impl Clone for cpuhead {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "cpuhead"]
    pub static mut cpuhead: cpuhead;
}
extern "C" {
    #[link_name = "cpuid_to_pcpu"]
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
}
extern "C" {
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: ::std::os::raw::c_int,
                         size: usize);
}
extern "C" {
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
}
extern "C" {
    pub fn dpcpu_alloc(size: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dpcpu_copy(s: *mut ::std::os::raw::c_void,
                      size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dpcpu_free(s: *mut ::std::os::raw::c_void,
                      size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dpcpu_init(dpcpu: *mut ::std::os::raw::c_void,
                      cpuid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pcpu_destroy(pcpu: *mut pcpu);
}
extern "C" {
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
}
extern "C" {
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: ::std::os::raw::c_int,
                     size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_profile_object([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lpohead {
    pub lh_first: *mut lock_profile_object,
}
#[test]
fn bindgen_test_layout_lpohead() {
    assert_eq!(::core::mem::size_of::<lpohead>() , 8usize);
    assert_eq!(::core::mem::align_of::<lpohead>() , 8usize);
}
impl Clone for lpohead {
    fn clone(&self) -> Self { *self }
}
pub type sdt_probe_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg0: usize,
                                                arg1: usize, arg2: usize,
                                                arg3: usize, arg4: usize)>;
extern "C" {
    #[link_name = "sdt_probe_func"]
    pub static mut sdt_probe_func: sdt_probe_func_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe {
    pub version: ::std::os::raw::c_int,
    pub prov: *mut sdt_provider,
    pub probe_entry: sdt_probe__bindgen_ty_1,
    pub argtype_list: sdt_probe__bindgen_ty_2,
    pub mod_: *const ::std::os::raw::c_char,
    pub func: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub id: id_t,
    pub n_args: ::std::os::raw::c_int,
    pub sdtp_lf: *mut linker_file,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_1 {
    pub tqe_next: *mut sdt_probe,
    pub tqe_prev: *mut *mut sdt_probe,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_1>() , 16usize);
    assert_eq!(::core::mem::align_of::<sdt_probe__bindgen_ty_1>() , 8usize);
}
impl Clone for sdt_probe__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_2 {
    pub tqh_first: *mut sdt_argtype,
    pub tqh_last: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_2>() , 16usize);
    assert_eq!(::core::mem::align_of::<sdt_probe__bindgen_ty_2>() , 8usize);
}
impl Clone for sdt_probe__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sdt_probe() {
    assert_eq!(::core::mem::size_of::<sdt_probe>() , 96usize);
    assert_eq!(::core::mem::align_of::<sdt_probe>() , 8usize);
}
impl Clone for sdt_probe {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider {
    pub name: *mut ::std::os::raw::c_char,
    pub prov_entry: sdt_provider__bindgen_ty_1,
    pub id: usize,
    pub sdt_refs: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider__bindgen_ty_1 {
    pub tqe_next: *mut sdt_provider,
    pub tqe_prev: *mut *mut sdt_provider,
}
#[test]
fn bindgen_test_layout_sdt_provider__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_provider__bindgen_ty_1>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<sdt_provider__bindgen_ty_1>() ,
               8usize);
}
impl Clone for sdt_provider__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sdt_provider() {
    assert_eq!(::core::mem::size_of::<sdt_provider>() , 40usize);
    assert_eq!(::core::mem::align_of::<sdt_provider>() , 8usize);
}
impl Clone for sdt_provider {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype {
    pub ndx: ::std::os::raw::c_int,
    pub type_: *const ::std::os::raw::c_char,
    pub xtype: *const ::std::os::raw::c_char,
    pub argtype_entry: sdt_argtype__bindgen_ty_1,
    pub probe: *mut sdt_probe,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype__bindgen_ty_1 {
    pub tqe_next: *mut sdt_argtype,
    pub tqe_prev: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_argtype__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_argtype__bindgen_ty_1>() , 16usize);
    assert_eq!(::core::mem::align_of::<sdt_argtype__bindgen_ty_1>() , 8usize);
}
impl Clone for sdt_argtype__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sdt_argtype() {
    assert_eq!(::core::mem::size_of::<sdt_argtype>() , 48usize);
    assert_eq!(::core::mem::align_of::<sdt_argtype>() , 8usize);
}
impl Clone for sdt_argtype {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sdt_probe_stub(arg1: u32, arg2: usize, arg3: usize, arg4: usize,
                          arg5: usize, arg6: usize);
}
extern "C" {
    #[link_name = "lockstat_enabled"]
    pub static mut lockstat_enabled: ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mtx_init(c: *mut usize, name: *const ::std::os::raw::c_char,
                     type_: *const ::std::os::raw::c_char,
                     opts: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _mtx_destroy(c: *mut usize);
}
extern "C" {
    pub fn mtx_sysinit(arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mtx_trylock_flags_(c: *mut usize, opts: ::std::os::raw::c_int,
                               file: *const ::std::os::raw::c_char,
                               line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_init();
}
extern "C" {
    pub fn __mtx_lock_sleep(c: *mut usize, v: usize, tid: usize,
                            opts: ::std::os::raw::c_int,
                            file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_sleep(c: *mut usize, opts: ::std::os::raw::c_int,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                            file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_spin_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                                 file: *const ::std::os::raw::c_char,
                                 line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_trylock_spin_flags(c: *mut usize,
                                    opts: ::std::os::raw::c_int,
                                    file: *const ::std::os::raw::c_char,
                                    line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mtx_unlock_spin_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                                   file: *const ::std::os::raw::c_char,
                                   line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn thread_lock_flags_(arg1: *mut thread, arg2: ::std::os::raw::c_int,
                              arg3: *const ::std::os::raw::c_char,
                              arg4: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx_pool([u8; 0]);
extern "C" {
    pub fn mtx_pool_create(mtx_name: *const ::std::os::raw::c_char,
                           pool_size: ::std::os::raw::c_int,
                           opts: ::std::os::raw::c_int) -> *mut mtx_pool;
}
extern "C" {
    pub fn mtx_pool_destroy(poolp: *mut *mut mtx_pool);
}
extern "C" {
    pub fn mtx_pool_find(pool: *mut mtx_pool,
                         ptr: *mut ::std::os::raw::c_void) -> *mut mtx;
}
extern "C" {
    pub fn mtx_pool_alloc(pool: *mut mtx_pool) -> *mut mtx;
}
extern "C" {
    #[link_name = "mtxpool_sleep"]
    pub static mut mtxpool_sleep: *mut mtx_pool;
}
extern "C" {
    #[link_name = "Giant"]
    pub static mut Giant: mtx;
}
extern "C" {
    #[link_name = "blocked_lock"]
    pub static mut blocked_lock: mtx;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx_args {
    pub ma_mtx: *mut ::std::os::raw::c_void,
    pub ma_desc: *const ::std::os::raw::c_char,
    pub ma_opts: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mtx_args() {
    assert_eq!(::core::mem::size_of::<mtx_args>() , 24usize);
    assert_eq!(::core::mem::align_of::<mtx_args>() , 8usize);
}
impl Clone for mtx_args {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry {
    pub ee_link: eventhandler_entry__bindgen_ty_1,
    pub ee_priority: ::std::os::raw::c_int,
    pub ee_arg: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_entry,
    pub tqe_prev: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry__bindgen_ty_1>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry__bindgen_ty_1>() ,
               8usize);
}
impl Clone for eventhandler_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_eventhandler_entry() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry>() , 32usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry>() , 8usize);
}
impl Clone for eventhandler_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list {
    pub el_name: *mut ::std::os::raw::c_char,
    pub el_flags: ::std::os::raw::c_int,
    pub el_runcount: u_int,
    pub el_lock: mtx,
    pub el_link: eventhandler_list__bindgen_ty_1,
    pub el_entries: eventhandler_list__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_list,
    pub tqe_prev: *mut *mut eventhandler_list,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<eventhandler_list__bindgen_ty_1>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<eventhandler_list__bindgen_ty_1>() ,
               8usize);
}
impl Clone for eventhandler_list__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_2 {
    pub tqh_first: *mut eventhandler_entry,
    pub tqh_last: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<eventhandler_list__bindgen_ty_2>() ,
               16usize);
    assert_eq!(::core::mem::align_of::<eventhandler_list__bindgen_ty_2>() ,
               8usize);
}
impl Clone for eventhandler_list__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_eventhandler_list() {
    assert_eq!(::core::mem::size_of::<eventhandler_list>() , 80usize);
    assert_eq!(::core::mem::align_of::<eventhandler_list>() , 8usize);
}
impl Clone for eventhandler_list {
    fn clone(&self) -> Self { *self }
}
pub type eventhandler_tag = *mut eventhandler_entry;
extern "C" {
    pub fn eventhandler_register(list: *mut eventhandler_list,
                                 name: *const ::std::os::raw::c_char,
                                 func: *mut ::std::os::raw::c_void,
                                 arg: *mut ::std::os::raw::c_void,
                                 priority: ::std::os::raw::c_int)
     -> eventhandler_tag;
}
extern "C" {
    pub fn eventhandler_deregister(list: *mut eventhandler_list,
                                   tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_find_list(name: *const ::std::os::raw::c_char)
     -> *mut eventhandler_list;
}
extern "C" {
    pub fn eventhandler_prune_list(list: *mut eventhandler_list);
}
pub type shutdown_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_pre_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_pre_sync() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_pre_sync>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_shutdown_pre_sync>()
               , 8usize);
}
impl Clone for eventhandler_entry_shutdown_pre_sync {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hack([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_post_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_post_sync() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_post_sync>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_shutdown_post_sync>()
               , 8usize);
}
impl Clone for eventhandler_entry_shutdown_post_sync {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_final {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_final() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_final>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_shutdown_final>() ,
               8usize);
}
impl Clone for eventhandler_entry_shutdown_final {
    fn clone(&self) -> Self { *self }
}
pub type power_change_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_resume {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_resume() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_resume>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_power_resume>() ,
               8usize);
}
impl Clone for eventhandler_entry_power_resume {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_suspend>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_power_suspend>() ,
               8usize);
}
impl Clone for eventhandler_entry_power_suspend {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend_early {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend_early() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_suspend_early>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_power_suspend_early>()
               , 8usize);
}
impl Clone for eventhandler_entry_power_suspend_early {
    fn clone(&self) -> Self { *self }
}
pub type vm_lowmem_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vm_lowmem {
    pub ee: eventhandler_entry,
    pub eh_func: vm_lowmem_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vm_lowmem() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vm_lowmem>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_vm_lowmem>() ,
               8usize);
}
impl Clone for eventhandler_entry_vm_lowmem {
    fn clone(&self) -> Self { *self }
}
pub type mountroot_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_mountroot {
    pub ee: eventhandler_entry,
    pub eh_func: mountroot_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_mountroot() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_mountroot>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_mountroot>() ,
               8usize);
}
impl Clone for eventhandler_entry_mountroot {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode([u8; 0]);
pub type vfs_mounted_notify_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut mount,
                                                arg3: *mut vnode,
                                                arg4: *mut thread)>;
pub type vfs_unmounted_notify_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut mount,
                                                arg3: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_mounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_mounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_mounted() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vfs_mounted>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_vfs_mounted>() ,
               8usize);
}
impl Clone for eventhandler_entry_vfs_mounted {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_unmounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_unmounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_unmounted() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vfs_unmounted>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_vfs_unmounted>() ,
               8usize);
}
impl Clone for eventhandler_entry_vfs_unmounted {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_params([u8; 0]);
pub type exitlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut proc_)>;
pub type forklist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut proc_,
                                                arg3: *mut proc_,
                                                arg4: ::std::os::raw::c_int)>;
pub type execlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut proc_,
                                                arg3: *mut image_params)>;
pub type proc_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut proc_)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_ctor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_ctor>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_process_ctor>() ,
               8usize);
}
impl Clone for eventhandler_entry_process_ctor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_dtor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_dtor>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_process_dtor>() ,
               8usize);
}
impl Clone for eventhandler_entry_process_dtor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_init {
    pub ee: eventhandler_entry,
    pub eh_func: proc_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_init() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_init>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_process_init>() ,
               8usize);
}
impl Clone for eventhandler_entry_process_init {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fini {
    pub ee: eventhandler_entry,
    pub eh_func: proc_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fini() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_fini>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_process_fini>() ,
               8usize);
}
impl Clone for eventhandler_entry_process_fini {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exit {
    pub ee: eventhandler_entry,
    pub eh_func: exitlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exit() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_exit>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_process_exit>() ,
               8usize);
}
impl Clone for eventhandler_entry_process_exit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fork {
    pub ee: eventhandler_entry,
    pub eh_func: forklist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fork() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_fork>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_process_fork>() ,
               8usize);
}
impl Clone for eventhandler_entry_process_fork {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exec {
    pub ee: eventhandler_entry,
    pub eh_func: execlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exec() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_exec>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_process_exec>() ,
               8usize);
}
impl Clone for eventhandler_entry_process_exec {
    fn clone(&self) -> Self { *self }
}
pub type app_coredump_start_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut thread,
                                                name:
                                                    *mut ::std::os::raw::c_char)>;
pub type app_coredump_progress_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                td: *mut thread,
                                                byte_count:
                                                    ::std::os::raw::c_int)>;
pub type app_coredump_finish_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                td: *mut thread)>;
pub type app_coredump_error_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                td: *mut thread,
                                                msg:
                                                    *mut ::std::os::raw::c_char, ...)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_start {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_start_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_start() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_start>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_app_coredump_start>()
               , 8usize);
}
impl Clone for eventhandler_entry_app_coredump_start {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_progress {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_progress_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_progress() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_progress>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_app_coredump_progress>()
               , 8usize);
}
impl Clone for eventhandler_entry_app_coredump_progress {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_finish {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_finish_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_finish() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_finish>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_app_coredump_finish>()
               , 8usize);
}
impl Clone for eventhandler_entry_app_coredump_finish {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_error {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_error_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_error() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_error>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_app_coredump_error>()
               , 8usize);
}
impl Clone for eventhandler_entry_app_coredump_error {
    fn clone(&self) -> Self { *self }
}
pub type thread_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_ctor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_ctor>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_thread_ctor>() ,
               8usize);
}
impl Clone for eventhandler_entry_thread_ctor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_dtor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_dtor>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_thread_dtor>() ,
               8usize);
}
impl Clone for eventhandler_entry_thread_dtor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_init {
    pub ee: eventhandler_entry,
    pub eh_func: thread_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_init() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_init>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_thread_init>() ,
               8usize);
}
impl Clone for eventhandler_entry_thread_init {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_fini {
    pub ee: eventhandler_entry,
    pub eh_func: thread_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_fini() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_fini>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_thread_fini>() ,
               8usize);
}
impl Clone for eventhandler_entry_thread_fini {
    fn clone(&self) -> Self { *self }
}
pub type uma_zone_chfn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbclusters_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbclusters_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_nmbclusters_change>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_nmbclusters_change>()
               , 8usize);
}
impl Clone for eventhandler_entry_nmbclusters_change {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbufs_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbufs_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_nmbufs_change>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_nmbufs_change>() ,
               8usize);
}
impl Clone for eventhandler_entry_nmbufs_change {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_maxsockets_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_maxsockets_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_maxsockets_change>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_maxsockets_change>()
               , 8usize);
}
impl Clone for eventhandler_entry_maxsockets_change {
    fn clone(&self) -> Self { *self }
}
pub type kld_load_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut linker_file)>;
pub type kld_unload_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2:
                                                    *const ::std::os::raw::c_char,
                                                arg3: caddr_t, arg4: usize)>;
pub type kld_unload_try_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut linker_file,
                                                arg3:
                                                    *mut ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_load {
    pub ee: eventhandler_entry,
    pub eh_func: kld_load_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_load() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_load>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_kld_load>() ,
               8usize);
}
impl Clone for eventhandler_entry_kld_load {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_unload>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_kld_unload>() ,
               8usize);
}
impl Clone for eventhandler_entry_kld_unload {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload_try {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_try_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload_try() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_unload_try>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_kld_unload_try>() ,
               8usize);
}
impl Clone for eventhandler_entry_kld_unload_try {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fb_info([u8; 0]);
pub type register_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut fb_info)>;
pub type unregister_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut fb_info)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_register_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: register_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_register_framebuffer() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_register_framebuffer>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_register_framebuffer>()
               , 8usize);
}
impl Clone for eventhandler_entry_register_framebuffer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_unregister_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: unregister_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_unregister_framebuffer() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_unregister_framebuffer>()
               , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_unregister_framebuffer>()
               , 8usize);
}
impl Clone for eventhandler_entry_unregister_framebuffer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cam_path([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ata_params([u8; 0]);
pub type ada_probe_veto_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut cam_path,
                                                arg3: *mut ata_params,
                                                arg4:
                                                    *mut ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ada_probe_veto {
    pub ee: eventhandler_entry,
    pub eh_func: ada_probe_veto_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ada_probe_veto() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_ada_probe_veto>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_ada_probe_veto>() ,
               8usize);
}
impl Clone for eventhandler_entry_ada_probe_veto {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swdevt([u8; 0]);
pub type swapon_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut swdevt)>;
pub type swapoff_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::std::os::raw::c_void,
                                                arg2: *mut swdevt)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapon {
    pub ee: eventhandler_entry,
    pub eh_func: swapon_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapon() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_swapon>() , 40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_swapon>() , 8usize);
}
impl Clone for eventhandler_entry_swapon {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapoff {
    pub ee: eventhandler_entry,
    pub eh_func: swapoff_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapoff() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_swapoff>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_swapoff>() ,
               8usize);
}
impl Clone for eventhandler_entry_swapoff {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct snapdata([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devfs_dirent([u8; 0]);
#[repr(C)]
#[derive(Copy)]
pub struct cdevsw {
    pub d_version: ::std::os::raw::c_int,
    pub d_flags: u_int,
    pub d_name: *const ::std::os::raw::c_char,
    pub d_open: d_open_t,
    pub d_fdopen: d_fdopen_t,
    pub d_close: d_close_t,
    pub d_read: d_read_t,
    pub d_write: d_write_t,
    pub d_ioctl: d_ioctl_t,
    pub d_poll: d_poll_t,
    pub d_mmap: d_mmap_t,
    pub d_strategy: d_strategy_t,
    pub d_dump: dumper_t,
    pub d_kqfilter: d_kqfilter_t,
    pub d_purge: d_purge_t,
    pub d_mmap_single: d_mmap_single_t,
    pub d_spare0: [i32; 3usize],
    pub d_spare1: [*mut ::std::os::raw::c_void; 3usize],
    pub d_devs: cdevsw__bindgen_ty_1,
    pub d_spare2: ::std::os::raw::c_int,
    pub __d_giant: cdevsw__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdevsw__bindgen_ty_1 {
    pub lh_first: *mut cdev,
}
#[test]
fn bindgen_test_layout_cdevsw__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<cdevsw__bindgen_ty_1>() , 8usize);
    assert_eq!(::core::mem::align_of::<cdevsw__bindgen_ty_1>() , 8usize);
}
impl Clone for cdevsw__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union cdevsw__bindgen_ty_2 {
    pub gianttrick: *mut cdevsw,
    pub postfree_list: cdevsw__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdevsw__bindgen_ty_2__bindgen_ty_1 {
    pub sle_next: *mut cdevsw,
}
#[test]
fn bindgen_test_layout_cdevsw__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<cdevsw__bindgen_ty_2__bindgen_ty_1>() ,
               8usize);
    assert_eq!(::core::mem::align_of::<cdevsw__bindgen_ty_2__bindgen_ty_1>() ,
               8usize);
}
impl Clone for cdevsw__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_cdevsw__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<cdevsw__bindgen_ty_2>() , 8usize);
    assert_eq!(::core::mem::align_of::<cdevsw__bindgen_ty_2>() , 8usize);
}
impl Clone for cdevsw__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_cdevsw() {
    assert_eq!(::core::mem::size_of::<cdevsw>() , 184usize);
    assert_eq!(::core::mem::align_of::<cdevsw>() , 8usize);
}
impl Clone for cdevsw {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buf([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct knote([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clonedevs([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_object([u8; 0]);
pub type d_open_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev,
                                                oflags: ::std::os::raw::c_int,
                                                devtype:
                                                    ::std::os::raw::c_int,
                                                td: *mut thread)
                               -> ::std::os::raw::c_int>;
pub type d_fdopen_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev,
                                                oflags: ::std::os::raw::c_int,
                                                td: *mut thread,
                                                fp: *mut file)
                               -> ::std::os::raw::c_int>;
pub type d_close_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev,
                                                fflag: ::std::os::raw::c_int,
                                                devtype:
                                                    ::std::os::raw::c_int,
                                                td: *mut thread)
                               -> ::std::os::raw::c_int>;
pub type d_strategy_t =
    ::core::option::Option<unsafe extern "C" fn(bp: *mut bio)>;
pub type d_ioctl_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev, cmd: u_long,
                                                data: caddr_t,
                                                fflag: ::std::os::raw::c_int,
                                                td: *mut thread)
                               -> ::std::os::raw::c_int>;
pub type d_read_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev, uio: *mut uio,
                                                ioflag: ::std::os::raw::c_int)
                               -> ::std::os::raw::c_int>;
pub type d_write_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev, uio: *mut uio,
                                                ioflag: ::std::os::raw::c_int)
                               -> ::std::os::raw::c_int>;
pub type d_poll_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev,
                                                events: ::std::os::raw::c_int,
                                                td: *mut thread)
                               -> ::std::os::raw::c_int>;
pub type d_kqfilter_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev,
                                                kn: *mut knote)
                               -> ::std::os::raw::c_int>;
pub type d_mmap_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev,
                                                offset: vm_ooffset_t,
                                                paddr: *mut vm_paddr_t,
                                                nprot: ::std::os::raw::c_int,
                                                memattr: *mut vm_memattr_t)
                               -> ::std::os::raw::c_int>;
pub type d_mmap_single_t =
    ::core::option::Option<unsafe extern "C" fn(cdev: *mut cdev,
                                                offset: *mut vm_ooffset_t,
                                                size: vm_size_t,
                                                object: *mut *mut vm_object,
                                                nprot: ::std::os::raw::c_int)
                               -> ::std::os::raw::c_int>;
pub type d_purge_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev)>;
pub type dumper_t =
    ::core::option::Option<unsafe extern "C" fn(_priv:
                                                    *mut ::std::os::raw::c_void,
                                                _virtual:
                                                    *mut ::std::os::raw::c_void,
                                                _physical: vm_offset_t,
                                                _offset: off_t,
                                                _length: usize)
                               -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct devsw_module_data {
    pub chainevh: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut module,
                                                              arg2:
                                                                  ::std::os::raw::c_int,
                                                              arg3:
                                                                  *mut ::std::os::raw::c_void)
                                             -> ::std::os::raw::c_int>,
    pub chainarg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_devsw_module_data() {
    assert_eq!(::core::mem::size_of::<devsw_module_data>() , 16usize);
    assert_eq!(::core::mem::align_of::<devsw_module_data>() , 8usize);
}
impl Clone for devsw_module_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn clone_setup(cdp: *mut *mut clonedevs);
}
extern "C" {
    pub fn clone_cleanup(arg1: *mut *mut clonedevs);
}
extern "C" {
    pub fn clone_create(arg1: *mut *mut clonedevs, arg2: *mut cdevsw,
                        unit: *mut ::std::os::raw::c_int, dev: *mut *mut cdev,
                        extra: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct make_dev_args {
    pub mda_size: usize,
    pub mda_flags: ::std::os::raw::c_int,
    pub mda_devsw: *mut cdevsw,
    pub mda_cr: *mut ucred,
    pub mda_uid: uid_t,
    pub mda_gid: gid_t,
    pub mda_mode: ::std::os::raw::c_int,
    pub mda_unit: ::std::os::raw::c_int,
    pub mda_si_drv1: *mut ::std::os::raw::c_void,
    pub mda_si_drv2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_make_dev_args() {
    assert_eq!(::core::mem::size_of::<make_dev_args>() , 64usize);
    assert_eq!(::core::mem::align_of::<make_dev_args>() , 8usize);
}
impl Clone for make_dev_args {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn make_dev_args_init_impl(_args: *mut make_dev_args, _sz: usize);
}
extern "C" {
    pub fn count_dev(_dev: *mut cdev) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn delist_dev(_dev: *mut cdev);
}
extern "C" {
    pub fn destroy_dev(_dev: *mut cdev);
}
extern "C" {
    pub fn destroy_dev_sched(dev: *mut cdev) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn destroy_dev_sched_cb(dev: *mut cdev,
                                cb:
                                    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                    *mut ::std::os::raw::c_void)>,
                                arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn destroy_dev_drain(csw: *mut cdevsw);
}
extern "C" {
    pub fn drain_dev_clone_events();
}
extern "C" {
    pub fn dev_refthread(_dev: *mut cdev, _ref: *mut ::std::os::raw::c_int)
     -> *mut cdevsw;
}
extern "C" {
    pub fn devvn_refthread(vp: *mut vnode, devp: *mut *mut cdev,
                           _ref: *mut ::std::os::raw::c_int) -> *mut cdevsw;
}
extern "C" {
    pub fn dev_relthread(_dev: *mut cdev, _ref: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dev_depends(_pdev: *mut cdev, _cdev: *mut cdev);
}
extern "C" {
    pub fn dev_ref(dev: *mut cdev);
}
extern "C" {
    pub fn dev_refl(dev: *mut cdev);
}
extern "C" {
    pub fn dev_rel(dev: *mut cdev);
}
extern "C" {
    pub fn make_dev(_devsw: *mut cdevsw, _unit: ::std::os::raw::c_int,
                    _uid: uid_t, _gid: gid_t, _perms: ::std::os::raw::c_int,
                    _fmt: *const ::std::os::raw::c_char, ...) -> *mut cdev;
}
extern "C" {
    pub fn make_dev_cred(_devsw: *mut cdevsw, _unit: ::std::os::raw::c_int,
                         _cr: *mut ucred, _uid: uid_t, _gid: gid_t,
                         _perms: ::std::os::raw::c_int,
                         _fmt: *const ::std::os::raw::c_char, ...)
     -> *mut cdev;
}
extern "C" {
    pub fn make_dev_credf(_flags: ::std::os::raw::c_int, _devsw: *mut cdevsw,
                          _unit: ::std::os::raw::c_int, _cr: *mut ucred,
                          _uid: uid_t, _gid: gid_t,
                          _mode: ::std::os::raw::c_int,
                          _fmt: *const ::std::os::raw::c_char, ...)
     -> *mut cdev;
}
extern "C" {
    pub fn make_dev_p(_flags: ::std::os::raw::c_int, _cdev: *mut *mut cdev,
                      _devsw: *mut cdevsw, _cr: *mut ucred, _uid: uid_t,
                      _gid: gid_t, _mode: ::std::os::raw::c_int,
                      _fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn make_dev_s(_args: *mut make_dev_args, _cdev: *mut *mut cdev,
                      _fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn make_dev_alias(_pdev: *mut cdev,
                          _fmt: *const ::std::os::raw::c_char, ...)
     -> *mut cdev;
}
extern "C" {
    pub fn make_dev_alias_p(_flags: ::std::os::raw::c_int,
                            _cdev: *mut *mut cdev, _pdev: *mut cdev,
                            _fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn make_dev_physpath_alias(_flags: ::std::os::raw::c_int,
                                   _cdev: *mut *mut cdev, _pdev: *mut cdev,
                                   _old_alias: *mut cdev,
                                   _physpath: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dev_lock();
}
extern "C" {
    pub fn dev_unlock();
}
pub type d_priv_dtor_t =
    ::core::option::Option<unsafe extern "C" fn(data:
                                                    *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn devfs_get_cdevpriv(datap: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devfs_set_cdevpriv(priv_: *mut ::std::os::raw::c_void,
                              dtr: d_priv_dtor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devfs_clear_cdevpriv();
}
extern "C" {
    pub fn devfs_alloc_cdp_inode() -> ino_t;
}
extern "C" {
    pub fn devfs_free_cdp_inode(ino: ino_t);
}
pub type dev_clone_fn =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::std::os::raw::c_void,
                                                cred: *mut ucred,
                                                name:
                                                    *mut ::std::os::raw::c_char,
                                                namelen:
                                                    ::std::os::raw::c_int,
                                                result: *mut *mut cdev)>;
extern "C" {
    pub fn dev_stdclone(_name: *mut ::std::os::raw::c_char,
                        _namep: *mut *mut ::std::os::raw::c_char,
                        _stem: *const ::std::os::raw::c_char,
                        _unit: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_dev_clone {
    pub ee: eventhandler_entry,
    pub eh_func: dev_clone_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_dev_clone() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_dev_clone>() ,
               40usize);
    assert_eq!(::core::mem::align_of::<eventhandler_entry_dev_clone>() ,
               8usize);
}
impl Clone for eventhandler_entry_dev_clone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kerneldumpcrypto([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kerneldumpheader([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dumperinfo {
    pub dumper: dumper_t,
    pub priv_: *mut ::std::os::raw::c_void,
    pub blocksize: u_int,
    pub maxiosize: u_int,
    pub mediaoffset: off_t,
    pub mediasize: off_t,
    pub blockbuf: *mut ::std::os::raw::c_void,
    pub kdc: *mut kerneldumpcrypto,
}
#[test]
fn bindgen_test_layout_dumperinfo() {
    assert_eq!(::core::mem::size_of::<dumperinfo>() , 56usize);
    assert_eq!(::core::mem::align_of::<dumperinfo>() , 8usize);
}
impl Clone for dumperinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn set_dumper(di: *mut dumperinfo,
                      devname: *const ::std::os::raw::c_char, td: *mut thread,
                      encrypt: u8, key: *const u8, encryptedkeysize: u32,
                      encryptedkey: *const u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dump_write(arg1: *mut dumperinfo,
                      arg2: *mut ::std::os::raw::c_void, arg3: vm_offset_t,
                      arg4: off_t, arg5: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dump_write_pad(arg1: *mut dumperinfo,
                          arg2: *mut ::std::os::raw::c_void,
                          arg3: vm_offset_t, arg4: off_t, arg5: usize,
                          arg6: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dump_write_header(di: *mut dumperinfo, kdh: *mut kerneldumpheader,
                             physical: vm_offset_t, offset: off_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dump_write_key(di: *mut dumperinfo, physical: vm_offset_t,
                          offset: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn doadump(arg1: boolean_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "dumping"]
    pub static mut dumping: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::core::mem::size_of::<iovec>() , 16usize);
    assert_eq!(::core::mem::align_of::<iovec>() , 8usize);
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uio_rw { UIO_READ = 0, UIO_WRITE = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum uio_seg { UIO_USERSPACE = 0, UIO_SYSSPACE = 1, UIO_NOCOPY = 2, }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dma_segment([u8; 0]);
extern "C" {
    pub fn cloneuio(uiop: *mut uio) -> *mut uio;
}
extern "C" {
    pub fn copyinfrom(src: *const ::std::os::raw::c_void,
                      dst: *mut ::std::os::raw::c_void, len: usize,
                      seg: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyiniov(iovp: *const iovec, iovcnt: u_int, iov: *mut *mut iovec,
                     error: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyinstrfrom(src: *const ::std::os::raw::c_void,
                         dst: *mut ::std::os::raw::c_void, len: usize,
                         copied: *mut usize, seg: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyinuio(iovp: *const iovec, iovcnt: u_int, uiop: *mut *mut uio)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyout_map(td: *mut thread, addr: *mut vm_offset_t, sz: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyout_unmap(td: *mut thread, addr: vm_offset_t, sz: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn physcopyin(src: *mut ::std::os::raw::c_void, dst: vm_paddr_t,
                      len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn physcopyout(src: vm_paddr_t, dst: *mut ::std::os::raw::c_void,
                       len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn physcopyin_vlist(src: *mut bus_dma_segment, offset: off_t,
                            dst: vm_paddr_t, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn physcopyout_vlist(src: vm_paddr_t, dst: *mut bus_dma_segment,
                             offset: off_t, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uiomove(cp: *mut ::std::os::raw::c_void, n: ::std::os::raw::c_int,
                   uio: *mut uio) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uiomove_frombuf(buf: *mut ::std::os::raw::c_void,
                           buflen: ::std::os::raw::c_int, uio: *mut uio)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uiomove_fromphys(ma: *mut *mut vm_page, offset: vm_offset_t,
                            n: ::std::os::raw::c_int, uio: *mut uio)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uiomove_nofault(cp: *mut ::std::os::raw::c_void,
                           n: ::std::os::raw::c_int, uio: *mut uio)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uiomove_object(obj: *mut vm_object, obj_size: off_t, uio: *mut uio)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_type_stats {
    pub mts_memalloced: u64,
    pub mts_memfreed: u64,
    pub mts_numallocs: u64,
    pub mts_numfrees: u64,
    pub mts_size: u64,
    pub _mts_reserved1: u64,
    pub _mts_reserved2: u64,
    pub _mts_reserved3: u64,
}
#[test]
fn bindgen_test_layout_malloc_type_stats() {
    assert_eq!(::core::mem::size_of::<malloc_type_stats>() , 64usize);
    assert_eq!(::core::mem::align_of::<malloc_type_stats>() , 8usize);
}
impl Clone for malloc_type_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct malloc_type_internal {
    pub mti_probes: [u32; 2usize],
    pub mti_zone: u_char,
    pub mti_stats: [malloc_type_stats; 256usize],
}
#[test]
fn bindgen_test_layout_malloc_type_internal() {
    assert_eq!(::core::mem::size_of::<malloc_type_internal>() , 16400usize);
    assert_eq!(::core::mem::align_of::<malloc_type_internal>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_type_stream_header {
    pub mtsh_version: u32,
    pub mtsh_maxcpus: u32,
    pub mtsh_count: u32,
    pub _mtsh_pad: u32,
}
#[test]
fn bindgen_test_layout_malloc_type_stream_header() {
    assert_eq!(::core::mem::size_of::<malloc_type_stream_header>() , 16usize);
    assert_eq!(::core::mem::align_of::<malloc_type_stream_header>() , 4usize);
}
impl Clone for malloc_type_stream_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_type_header {
    pub mth_name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_malloc_type_header() {
    assert_eq!(::core::mem::size_of::<malloc_type_header>() , 32usize);
    assert_eq!(::core::mem::align_of::<malloc_type_header>() , 1usize);
}
impl Clone for malloc_type_header {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "M_CACHE"]
    pub static mut M_CACHE: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_DEVBUF"]
    pub static mut M_DEVBUF: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_TEMP"]
    pub static mut M_TEMP: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_IOV"]
    pub static mut M_IOV: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "malloc_mtx"]
    pub static mut malloc_mtx: mtx;
}
pub type malloc_type_list_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut malloc_type,
                                                arg2:
                                                    *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn contigfree(addr: *mut ::std::os::raw::c_void,
                      size: ::std::os::raw::c_ulong, type_: *mut malloc_type);
}
extern "C" {
    pub fn contigmalloc(size: ::std::os::raw::c_ulong,
                        type_: *mut malloc_type, flags: ::std::os::raw::c_int,
                        low: vm_paddr_t, high: vm_paddr_t,
                        alignment: ::std::os::raw::c_ulong,
                        boundary: vm_paddr_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(addr: *mut ::std::os::raw::c_void, type_: *mut malloc_type);
}
extern "C" {
    pub fn malloc(size: ::std::os::raw::c_ulong, type_: *mut malloc_type,
                  flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_init(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn malloc_last_fail() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc_type_allocated(type_: *mut malloc_type,
                                 size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_freed(type_: *mut malloc_type,
                             size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_list(arg1: malloc_type_list_func_t,
                            arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn malloc_uninit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(addr: *mut ::std::os::raw::c_void,
                   size: ::std::os::raw::c_ulong, type_: *mut malloc_type,
                   flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocf(addr: *mut ::std::os::raw::c_void,
                    size: ::std::os::raw::c_ulong, type_: *mut malloc_type,
                    flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_desc2type(desc: *const ::std::os::raw::c_char)
     -> *mut malloc_type;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kproc_desc {
    pub arg0: *const ::std::os::raw::c_char,
    pub func: ::core::option::Option<unsafe extern "C" fn()>,
    pub global_procpp: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_kproc_desc() {
    assert_eq!(::core::mem::size_of::<kproc_desc>() , 24usize);
    assert_eq!(::core::mem::align_of::<kproc_desc>() , 8usize);
}
impl Clone for kproc_desc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kthread_desc {
    pub arg0: *const ::std::os::raw::c_char,
    pub func: ::core::option::Option<unsafe extern "C" fn()>,
    pub global_threadpp: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_kthread_desc() {
    assert_eq!(::core::mem::size_of::<kthread_desc>() , 24usize);
    assert_eq!(::core::mem::align_of::<kthread_desc>() , 8usize);
}
impl Clone for kthread_desc {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn kproc_create(arg1:
                            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut ::std::os::raw::c_void)>,
                        arg2: *mut ::std::os::raw::c_void,
                        arg3: *mut *mut proc_, flags: ::std::os::raw::c_int,
                        pages: ::std::os::raw::c_int,
                        arg4: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kproc_exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn kproc_resume(arg1: *mut proc_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kproc_shutdown(arg1: *mut ::std::os::raw::c_void,
                          arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn kproc_start(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn kproc_suspend(arg1: *mut proc_, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kproc_suspend_check(arg1: *mut proc_);
}
extern "C" {
    pub fn kproc_kthread_add(arg1:
                                 ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut ::std::os::raw::c_void)>,
                             arg2: *mut ::std::os::raw::c_void,
                             arg3: *mut *mut proc_, arg4: *mut *mut thread,
                             flags: ::std::os::raw::c_int,
                             pages: ::std::os::raw::c_int,
                             procname: *const ::std::os::raw::c_char,
                             arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kthread_add(arg1:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::std::os::raw::c_void)>,
                       arg2: *mut ::std::os::raw::c_void, arg3: *mut proc_,
                       arg4: *mut *mut thread, flags: ::std::os::raw::c_int,
                       pages: ::std::os::raw::c_int,
                       arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kthread_exit();
}
extern "C" {
    pub fn kthread_resume(arg1: *mut thread) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kthread_shutdown(arg1: *mut ::std::os::raw::c_void,
                            arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn kthread_start(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn kthread_suspend(arg1: *mut thread, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kthread_suspend_check();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
